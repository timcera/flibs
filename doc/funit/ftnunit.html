
<html><head>
<title>flibs/ftnunit - flibs</title>
<style type="text/css"><!--
    HTML {
	background: 	#FFFFFF;
	color: 		black;
    }
    BODY {
	background: 	#FFFFFF;
	color:	 	black;
    }
    DIV.doctools {
	margin-left:	10%;
	margin-right:	10%;
    }
    DIV.doctools H1,DIV.doctools H2 {
	margin-left:	-5%;
    }
    H1, H2, H3, H4 {
	margin-top: 	1em;
	font-family:	sans-serif;
	font-size:	large;
	color:		#005A9C;
	background: 	transparent;
	text-align:		left;
    }
    H1.doctools_title {
	text-align: center;
    }
    UL,OL {
	margin-right: 0em;
	margin-top: 3pt;
	margin-bottom: 3pt;
    }
    UL LI {
	list-style: disc;
    }
    OL LI {
	list-style: decimal;
    }
    DT {
	padding-top: 	1ex;
    }
    UL.doctools_toc,UL.doctools_toc UL, UL.doctools_toc UL UL {
	font:		normal 12pt/14pt sans-serif;
	list-style:	none;
    }
    LI.doctools_section, LI.doctools_subsection {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding: 	0em;
    }
    PRE {
	display: 	block;
	font-family:	monospace;
	white-space:	pre;
	margin:		0%;
	padding-top:	0.5ex;
	padding-bottom:	0.5ex;
	padding-left:	1ex;
	padding-right:	1ex;
	width:		100%;
    }
    PRE.doctools_example {
	color: 		black;
	background: 	#f5dcb3;
	border:		1px solid black;
    }
    UL.doctools_requirements LI, UL.doctools_syntax LI {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding:	0em;
    }
    DIV.doctools_synopsis {
	color: 		black;
	background: 	#80ffff;
	border:		1px solid black;
	font-family:	serif;
	margin-top: 	1em;
	margin-bottom: 	1em;
    }
    UL.doctools_syntax {
	margin-top: 	1em;
	border-top:	1px solid black;
    }
    UL.doctools_requirements {
	margin-bottom: 	1em;
	border-bottom:	1px solid black;
    }
--></style>
</head>
<! -- Generated from file 'ftnunit.man' by tcllib/doctools with format 'html'
   -->
<! -- Copyright &copy; 2009 Arjen Markus &lt;arjenmarkus@sourceforge.net&gt;
   -->
<! -- flibs/ftnunit.n
   -->
<body><div class="doctools">
<h1 class="doctools_title">flibs/ftnunit(n) 1.2  &quot;flibs&quot;</h1>
<div id="name" class="doctools_section"><h2><a name="name">Name</a></h2>
<p>flibs/ftnunit - Unit testing</p>
</div>
<div id="toc" class="doctools_section"><h2><a name="toc">Table Of Contents</a></h2>
<ul class="doctools_toc">
<li class="doctools_section"><a href="#toc">Table Of Contents</a></li>
<li class="doctools_section"><a href="#synopsis">Synopsis</a></li>
<li class="doctools_section"><a href="#section1">Description</a></li>
<li class="doctools_section"><a href="#section2">OUTPUT</a></li>
<li class="doctools_section"><a href="#section3">ROUTINES</a></li>
<li class="doctools_section"><a href="#section4">CUSTOMISATION</a></li>
<li class="doctools_section"><a href="#section5">GENERATING TESTS FROM A TABLE</a></li>
<li class="doctools_section"><a href="#section6">TODO</a></li>
<li class="doctools_section"><a href="#section7">RELATED WORK</a></li>
<li class="doctools_section"><a href="#copyright">Copyright</a></li>
</ul>
</div>
<div id="synopsis" class="doctools_section"><h2><a name="synopsis">Synopsis</a></h2>
<div class="doctools_synopsis">
<ul class="doctools_syntax">
<li><a href="#1">runtests.bat</a></li>
<li><a href="#2">runtests.sh</a></li>
<li><a href="#3">runtests.tcl</a></li>
<li><a href="#4">ftnunitgui.tcl</a></li>
<li><a href="#5"><b class="cmd">call runtests( testproc )</b></a></li>
<li><a href="#6"><b class="cmd">call runtests_init</b></a></li>
<li><a href="#7"><b class="cmd">call runtests_final( stop )</b></a></li>
<li><a href="#8"><b class="cmd">call test( proc, text, ignore )</b></a></li>
<li><a href="#9"><b class="cmd">call assert_true( cond, text )</b></a></li>
<li><a href="#10"><b class="cmd">call assert_false( cond, text )</b></a></li>
<li><a href="#11"><b class="cmd">call assert_equal( value1, value2, text )</b></a></li>
<li><a href="#12"><b class="cmd">call assert_comparable( value1, value2, margin, text )</b></a></li>
<li><a href="#13"><b class="cmd">call assert_inbetween( value, vmin, vmax, text )</b></a></li>
<li><a href="#14"><b class="cmd">call assert_files_comparable( filename1, filename2, margin, text )</b></a></li>
<li><a href="#15"><b class="cmd">exists = ftnunit_file_exists( filename )</b></a></li>
<li><a href="#16"><b class="cmd">call ftnunit_get_lun( lun )</b></a></li>
<li><a href="#17"><b class="cmd">call ftnunit_remove_file( filename )</b></a></li>
<li><a href="#18"><b class="cmd">call ftnunit_make_empty_file( filename )</b></a></li>
<li><a href="#19">cmd call ftnunit_hook_test_start( text )</a></li>
<li><a href="#20">cmd call ftnunit_hook_test_stop( text )</a></li>
<li><a href="#21"><b class="cmd">call ftnunit_hook_test_failure( text, assert_text, failure_text )</b></a></li>
<li><a href="#22"><b class="cmd">call ftnunit_hook_test_complete</b></a></li>
</ul>
</div>
</div>
<div id="section1" class="doctools_section"><h2><a name="section1">Description</a></h2>
<p><em>JUnit</em> is a well-known facility for defining and running unit
tests in Java programs. The <em>ftnunit</em> framework was inspired by
that facility. It is not as good-looking as JUnit, by no means:</p>
<ul class="doctools_itemized">
<li><p>It has a simple graphical user-interface that does not group the tests.</p></li>
<li><p>As Fortran does not allow introspection, the test routines can not
be detected automatically, instead as a programmer you need to set up a
high-level routine yourself that collects all the unit tests.</p></li>
<li><p>A runtime error, like division by zero, may lead to a termination of
the program. There is no (portable) way to catch these. Instead, the
framework relies on a batch file or shell script to repeatedly start the
program until all tests are run.</p></li>
</ul>
<p>Despite these limitations, <em>ftnunit</em> can be a great help:</p>
<ul class="doctools_itemized">
<li><p>The Tcl program <em>gentabletest.tcl</em> generates a complete test program based
on a simple input file (see <span class="sectref"><a href="#section5">GENERATING TESTS FROM A TABLE</a></span>).</p></li>
<li><p>The code to test the various components (subroutines, functions, tasks
consisting of several program units) can be combined with the program
itself, without interfering with the ordinary code.</p>
<p>This is achieved by defining a single routine (test_all, say) that runs
all the unit tests and that is called via the provided routine
<em>runtests</em>:</p>
<pre class="doctools_example">
program myprog
    ...
!
! The routine runtests will check if unit tests are requested
! If not, it will return immediately. This way we make sure
! the unit tests remain part of the program.
!
! The routine test_all runs all unit tests
! (see the dataproc_testing module)
!
    call runtests( test_all )
!
! Ordinary processing
!
    ...
end program
</pre>
<p>The routine runtests checks if there is a file &quot;ftnunit.run&quot;. If there is
such a file, it will run the given subroutine. Otherwise it will return
and the rest of the program is executed.</p></li>
<li><p>Because the test code is incorporated in the program itself, it is less
likely that they evolve independently: changes in the argument lists of
the subroutines and functions may lead to compile errors in the test
code.</p></li>
<li><p>There is no need to set up a whole new program for testing portions of
the program.</p></li>
</ul>
<p>The source file &quot;test_ftnunit.f90&quot; illustrates how to use the <em>ftnunit</em>
framework:</p>
<ul class="doctools_itemized">
<li><p>The main program calls the routine &quot;runtests&quot; and passes it the argument
&quot;test_all&quot;, a routine defined in a module called &quot;dataproc_testing&quot;.</p></li>
<li><p>The routine &quot;test_all&quot; consists of nothing but calls to the generic
routine &quot;test&quot;:</p>
<pre class="doctools_example">
subroutine test_all
    call test( test_no_file, &quot;Read non-existent file&quot; )
    call test( test_empty_file, &quot;Read an empty file&quot; )
    call test( test_invalid_file, &quot;Read an invalid file&quot; )
    call test( test_ordinary_file, &quot;Read an ordinary file&quot; )
end subroutine test_all
</pre>
</li>
<li><p>The module includes a source file &quot;ftnunit_test.f90&quot;. This is a remnant
of a previous version. Please ignore this.</p></li>
<li><p>The generic routine &quot;test&quot; checks whether a particular unit
test needs to be run (via the test number) and then runs the subroutine
that was passed as one of its arguments. One such routine looks like
this:</p>
<pre class="doctools_example">
subroutine test_no_file
    integer :: nodata
    real    :: vmean, vmin, vmax
    call ftnunit_remove_file( 'no_such_file' )
    call write_name( 'no_such_file' )
    call open_files
    call process_data( nodata, vmean, vmax, vmin )
    call assert_true( nodata == 0, &quot;No data read&quot; )
end subroutine test_no_file
</pre>
<p>The assertion is used to check that the result is as expected.</p></li>
<li><p>The program contains some deliberate errors and the resulting
log file looks like this:</p>
<pre class="doctools_example">
Test: Read non-existent file
Test: Read an empty file
Test: Read an invalid file
forrtl: severe (59): list-directed I/O syntax error, unit 11, file c:\arjen\flibs\tests\ftnunit\invalid_file
Image              PC        Routine            Line        Source
test_ftnunit.exe     004151B9  Unknown               Unknown  Unknown
test_ftnunit.exe     00415017  Unknown               Unknown  Unknown
test_ftnunit.exe     004141F4  Unknown               Unknown  Unknown
test_ftnunit.exe     00414629  Unknown               Unknown  Unknown
test_ftnunit.exe     00409C05  Unknown               Unknown  Unknown
test_ftnunit.exe     004095FB  Unknown               Unknown  Unknown
test_ftnunit.exe     0040144B  Unknown               Unknown  Unknown
test_ftnunit.exe     00401FE9  Unknown               Unknown  Unknown
test_ftnunit.exe     00401A2C  Unknown               Unknown  Unknown
test_ftnunit.exe     00401BB3  Unknown               Unknown  Unknown
test_ftnunit.exe     0040294A  Unknown               Unknown  Unknown
test_ftnunit.exe     0040232E  Unknown               Unknown  Unknown
test_ftnunit.exe     0044A1E9  Unknown               Unknown  Unknown
test_ftnunit.exe     00433519  Unknown               Unknown  Unknown
kernel32.dll       7C816D4F  Unknown               Unknown  Unknown
Incrementally linked image--PC correlation disabled.
Test: Read an ordinary file
Number of failed assertions:                    0
Number of runs needed to complete the tests:    3
</pre>
</li>
</ul>
<p>The program is run via one of the following files:</p>
<dl class="doctools_definitions">
<dt><a name="1">runtests.bat</a></dt>
<dd><p>A batch file for use under MS Windows</p></dd>
<dt><a name="2">runtests.sh</a></dt>
<dd><p>A Bourne shell script for use under UNIX/Linux or similar systems, like
Cygwin or Mingw.</p></dd>
<dt><a name="3">runtests.tcl</a></dt>
<dd><p>A Tcl program that presents a simple graphical user-interface</p></dd>
<dt><a name="4">ftnunitgui.tcl</a></dt>
<dd><p>A Tcl-based graphical user-interface that allows you to run tests one at a time</p></dd>
</dl>
</div>
<div id="section2" class="doctools_section"><h2><a name="section2">OUTPUT</a></h2>
<p>When you run a program in test mode via the batch file/shell script,
it produces two output files:</p>
<ul class="doctools_itemized">
<li><p><em>runtests.log</em> contains all the output that was written to the screen.</p></li>
<li><p><em>ftnunit.html</em> is an HTML file with a summary of the tests and a colour
encoding to indicate the test cases that succeeded or failed.</p></li>
</ul>
</div>
<div id="section3" class="doctools_section"><h2><a name="section3">ROUTINES</a></h2>
<p>The module <em>ftnunit</em> contains the following subroutines and functions:</p>
<dl class="doctools_definitions">
<dt><a name="5"><b class="cmd">call runtests( testproc )</b></a></dt>
<dd><p>Routine to start the unit tests. It checks if the file &quot;ftnunit.run&quot;
exists. If so, it will call the subroutine <em>testproc</em> that was
passed. Otherwise it will simply return, so that the ordinary program
execution may continue.</p>
<p>If the subroutine testproc returns, the program stops, unless you have
called the subroutine <em>runtests_init</em> before <em>runtests</em>.</p>
<dl class="doctools_arguments">
<dt>subroutine <i class="arg">testproc</i></dt>
<dd><p>Subroutine that calls the individual test routines. It takes no
arguments. It wil generally exist of a series of calls to the
routine <em>test</em> - see below.</p></dd>
</dl></dd>
<dt><a name="6"><b class="cmd">call runtests_init</b></a></dt>
<dd><p>Routine to initialise the ftnunit system, so that you call <em>runtests</em>
more than once. To complete the tests, call <em>runtests_final</em>, as
this will print the final statistics and stop the program.</p></dd>
<dt><a name="7"><b class="cmd">call runtests_final( stop )</b></a></dt>
<dd><p>Routine to finalise the ftnunit system: it will print the final statistics
and stop the program, but only if the file &quot;ftnunit.run&quot; is present.</p>
<dl class="doctools_arguments">
<dt>logical, optional, intent(in) <i class="arg">stop</i></dt>
<dd><p>If present and set to true, the routine will not stop the program.
Instead it returns and the program continues working.</p></dd>
</dl></dd>
<dt><a name="8"><b class="cmd">call test( proc, text, ignore )</b></a></dt>
<dd><p>Routine to run the individual unit test routine (emph proc). It decides
if the test has not run yet and if so, the test routine is called.
Otherwise it is skipped.</p>
<p><em>test</em> takes care of all administrative details.</p>
<dl class="doctools_arguments">
<dt>subroutine <i class="arg">proc</i></dt>
<dd><p>Subroutine that implements an individual unit test. It takes no
arguments. Within each such subroutine the complete unit test is run.</p></dd>
<dt>character(len=*), intent(in) <i class="arg">text</i></dt>
<dd><p>Text describing the particular unit test. It is printed in the log
file.</p></dd>
<dt>logical, optional, intent(in) <i class="arg">ignore</i></dt>
<dd><p>If present and set to true, the test routine will not be actually run.
Instead it is shown as &quot;ignored&quot;. This feature is useful if the code to
be tested is not yet ready for testing.
file.</p></dd>
</dl></dd>
<dt><a name="9"><b class="cmd">call assert_true( cond, text )</b></a></dt>
<dd><p>Routine to check that a condition is true. If not, a message is printed
in the log file and the number of failures is increased.</p>
<dl class="doctools_arguments">
<dt>logical <i class="arg">cond</i></dt>
<dd><p>The condition to be checked</p></dd>
<dt>character(len=*), intent(in) <i class="arg">text</i></dt>
<dd><p>Text describing the condition</p></dd>
</dl></dd>
<dt><a name="10"><b class="cmd">call assert_false( cond, text )</b></a></dt>
<dd><p>Routine to check that a condition is false. If not, a message is
printed in the log file and the number of failures is increased.</p>
<dl class="doctools_arguments">
<dt>logical <i class="arg">cond</i></dt>
<dd><p>The condition to be checked</p></dd>
<dt>character(len=*), intent(in) <i class="arg">text</i></dt>
<dd><p>Text describing the condition</p></dd>
</dl></dd>
<dt><a name="11"><b class="cmd">call assert_equal( value1, value2, text )</b></a></dt>
<dd><p>Routine to check that two logicals, two strings, or two integers are equal
or if two one-dimensional integer, logical or string arrays are equal. If not, a message is
printed, along with the values that were different.</p>
<dl class="doctools_arguments">
<dt>&lt;type&gt; <i class="arg">value1</i></dt>
<dd><p>The first integer/logical/string value</p></dd>
<dt>&lt;type&gt; <i class="arg">value2</i></dt>
<dd><p>The second integer/logical/string value</p></dd>
<dt>character(len=*), intent(in) <i class="arg">text</i></dt>
<dd><p>Text describing the condition</p></dd>
</dl>
<p>Or:</p>
<dl class="doctools_arguments">
<dt>integer [, dimension(:)] <i class="arg">value1</i></dt>
<dd><p>The first integer value or array</p></dd>
<dt>integer [, dimension(:)] <i class="arg">value2</i></dt>
<dd><p>The second integer value or array</p></dd>
<dt>character(len=*), intent(in) <i class="arg">text</i></dt>
<dd><p>Text describing the condition</p></dd>
</dl></dd>
<dt><a name="12"><b class="cmd">call assert_comparable( value1, value2, margin, text )</b></a></dt>
<dd><p>Routine to check that two reals are almost equal or if two one-dimensional
real arrays (single or double precision) are almost equal. If not, a message
is printed, along with the values that were different.</p>
<p>The margin is taken as a relative tolerance. Two values are
considered almost equal if:</p>
<pre class="doctools_example">    abs( v1 - v2 ) &lt; margin * (abs(v1)+abs(v2)) / 2 </pre>
<dl class="doctools_arguments">
<dt>real [, dimension(:)] <i class="arg">value1</i></dt>
<dd><p>The first real value or array</p></dd>
<dt>real [, dimension(:)] <i class="arg">value2</i></dt>
<dd><p>The second real value or array</p></dd>
<dt>character(len=*), intent(in) <i class="arg">text</i></dt>
<dd><p>Text describing the condition</p></dd>
</dl></dd>
<dt><a name="13"><b class="cmd">call assert_inbetween( value, vmin, vmax, text )</b></a></dt>
<dd><p>Routine to check that a (single or double precision) real value lies between
two given bounds. This establishes an absolute range for the values, rather than
a relative.</p>
<dl class="doctools_arguments">
<dt>real <i class="arg">value</i></dt>
<dd><p>The real value to be tested</p></dd>
<dt>real <i class="arg">vmin</i></dt>
<dd><p>The minimum value that is allowed</p></dd>
<dt>real <i class="arg">vmax</i></dt>
<dd><p>The maximum value that is allowed</p></dd>
</dl></dd>
<dt><a name="14"><b class="cmd">call assert_files_comparable( filename1, filename2, margin, text )</b></a></dt>
<dd><p>Routine to check that two files are equal or almost equal. The files are scanned
line by line and item by item. If an item can be interpreted as a number, then
the comparison is done using a margin, otherwise the corresponding items are
considered strings and should be exactly equal.</p>
<p>A report is produced of all differing lines.</p>
<p>The margin is taken as a relative tolerance. Two numerical values are
considered almost equal if:</p>
<pre class="doctools_example">
    abs( v1 - v2 ) &lt; margin * (abs(v1)+abs(v2)) / 2 </pre>
<dl class="doctools_arguments">
<dt>character(len=*) <i class="arg">filename1</i></dt>
<dd><p>The name of the first file to read</p></dd>
<dt>character(len=*) <i class="arg">filename2</i></dt>
<dd><p>The name of the second file to read</p></dd>
<dt>character(len=*), intent(in) <i class="arg">text</i></dt>
<dd><p>Text describing the condition</p></dd>
</dl></dd>
<dt><a name="15"><b class="cmd">exists = ftnunit_file_exists( filename )</b></a></dt>
<dd><p>Logical function to check that a particular file exists</p>
<dl class="doctools_arguments">
<dt>character(len=*), intent(in) <i class="arg">filename</i></dt>
<dd><p>Name of the file to be checked</p></dd>
</dl></dd>
<dt><a name="16"><b class="cmd">call ftnunit_get_lun( lun )</b></a></dt>
<dd><p>Subroutine to get a free LU-number</p>
<dl class="doctools_arguments">
<dt>integer, intent(out) <i class="arg">lun</i></dt>
<dd><p>Next free LU-number</p></dd>
</dl></dd>
<dt><a name="17"><b class="cmd">call ftnunit_remove_file( filename )</b></a></dt>
<dd><p>Subroutine to remove (delete) a file</p>
<dl class="doctools_arguments">
<dt>character(len=*), intent(in) <i class="arg">filename</i></dt>
<dd><p>Name of the file to be removed</p></dd>
</dl></dd>
<dt><a name="18"><b class="cmd">call ftnunit_make_empty_file( filename )</b></a></dt>
<dd><p>Subroutine to make a new, empty file</p>
<dl class="doctools_arguments">
<dt>character(len=*), intent(in) <i class="arg">filename</i></dt>
<dd><p>Name of the file to be created</p></dd>
</dl></dd>
</dl>
</div>
<div id="section4" class="doctools_section"><h2><a name="section4">CUSTOMISATION</a></h2>
<p>The module <em>ftnunit_hooks</em> can be used to customise the output
of <em>ftnunit</em> to a certain extent. It provides four routines
that you can easily adapt to your needs:</p>
<dl class="doctools_definitions">
<dt><a name="19">cmd call ftnunit_hook_test_start( text )</a></dt>
<dd><p>]
Routine to signal the start of a test.</p>
<dl class="doctools_arguments">
<dt>string <i class="arg">text</i></dt>
<dd><p>The descriptive text passed to the routine <em>test</em>.</p></dd>
</dl></dd>
<dt><a name="20">cmd call ftnunit_hook_test_stop( text )</a></dt>
<dd><p>]
Routine to signal the end of a test.</p>
<dl class="doctools_arguments">
<dt>string <i class="arg">text</i></dt>
<dd><p>The descriptive text passed to the routine <em>test</em>.</p></dd>
</dl></dd>
<dt><a name="21"><b class="cmd">call ftnunit_hook_test_failure( text, assert_text, failure_text )</b></a></dt>
<dd><p>Routine to signal that an assertion has failed (and therefore the test).</p>
<dl class="doctools_arguments">
<dt>string <i class="arg">text</i></dt>
<dd><p>The descriptive text passed to the routine <em>test</em>.</p></dd>
<dt>string <i class="arg">assert_text</i></dt>
<dd><p>Text describing the assertion</p></dd>
<dt>string <i class="arg">failure_text</i></dt>
<dd><p>The text describing the reason of the failure</p></dd>
</dl></dd>
<dt><a name="22"><b class="cmd">call ftnunit_hook_test_complete</b></a></dt>
<dd><p>Routine called after the tests have been run (for instance to start and
Internet browser to view the HTML report).</p></dd>
</dl>
<p>Note that the default implementation consists of empty routine.</p>
<p>As an example of customisation, under Windows, you could start the
default Internet browser showing the HTML file like this:
    subroutine ftnunit_hook_test_complete
        call system( &quot;ftnunit.html&quot; )
    end subroutine ftnunit_hook_test_complete
provided an association for files with extension &quot;html&quot; exists.</p>
</div>
<div id="section5" class="doctools_section"><h2><a name="section5">GENERATING TESTS FROM A TABLE</a></h2>
<p>The Tcl program &quot;gentabletest.tcl&quot; reads the test specifications from an
input file and generates a complete Fortran program. The ideas from
Bil Kleb's  &quot;Toward Scientific Numerical Modeling&quot;
<a href="ftp://ftp.rta.nato.int/PubFullText/RTO/MP/RTO-MP-AVT-147/RTO-MP-AVT-147-P-17-Kleb.pdf">ftp://ftp.rta.nato.int/PubFullText/RTO/MP/RTO-MP-AVT-147/RTO-MP-AVT-147-P-17-Kleb.pdf</a>
were used for the set-up.</p>
<p>To do: provide a detailed description. For the moment: see <em>example.tbl</em>, including below.</p>
<pre class="doctools_example">
! Example of generating test code via a table
! -------------------------------------------
! The routine to be tested determines the minimum oxygen concentration
! in a river, based on the Streeter-Phelps model:
!
!    dBOD/dt = -k * BOD
!
!    dO2/dt = -k * BOD + ka * (O2sat-O2) / H
!
! where
!    BOD   - biological oxygen demand (mg O2/l)
!    O2    - oxygen concentration (mg O2/l)
!    O2sat - saturation concentration of oxygen (mg O2/l)
!    k     - decay rate of BOD (1/day)
!    ka    - reareation rate of oxygen (m/day)
!    H     - depth of the river
!
! We need boundary (initial) conditions for BOD and oxygen and
! the equations describe the concentrations of BOD and oxygen in a
! packet of water as it flows along the river.
!
! Note:
! It is a very simple model, it is not meant as a realistic
! representation.
!
! The routine simply continues the solution until a minimum is found.
! The results are: oxymin and time
!
!
! The keyword DECLARATIONS introduces the declarations we need for the
! complete generated code
!
DECLARATIONS
    use streeter_phelps
    real :: bod, oxy
    real :: k, ka, h, oxysat, dt, oxymin, time
!
! The keyword CODE introduces the code fragment required to run the
! routine or routines. The results and possible checking of error
! conditions are separated.
!
CODE
    call compute_min_oxygen( bod, oxy, k, ka, h, oxysat, dt, oxymin, time )
!
! The keyword RESULT indicates which arguments/variables hold the
! interesting results. Specify one name per line (you can not currently
! use array elements) and the allowed margin (taken as absolute, if
! followed by &quot;%&quot; as a percentage)
!
RESULT
    oxymin  0.001        ! Minimum oxygen concentration
    time    0.01%        ! Time the minimum is reached
!
! The keyword ERROR is used for a code fragment that checks if the
! routine has correctly found an error in the input (that is, some
! parameter value is out of range). The code is invoked when any of
! result variables in a table entry has the keyword ERROR instead of
! a proper value.
! Use the subroutine &quot;error&quot; to indicate the correctly reported error
! condition.
!
ERROR
    if ( time == -999.0 ) then
        call error
    endif
!
! The keyword RANGES specifies that the variables are to be taken
! from a uniform or a normal distribution. The generated program will
! simply select values at random and run the code with them. The report
! consists of the detailed output as well as a summary.
!
RANGES
    oxy   10.0   2.0  Uniform ! Name of the variable, the mean and the margin (uniform)
                              ! Normal: mean and standard deviation followed by Normal
                              ! Note: all parameters must be given!
!
! The keyword TABLE indicates the beginning of a table of input data and
! expected values. The first (non-comment) line contains the names of
! the variables as used in the code fragments and all others are the
! values expected.
!
! There are two special values:
! ? -     indicating an unknown value for result variables and a &quot;do not
!         care&quot; value for input variables
!         It is useful to generate a table that does contain the (computed)
!         results (see the file table.out) or to indicate situations
!         where one or more input variables are out of range and this
!         should lead to an error
! ERROR - indicating that the entry should cause the routine to be
!         tested to flag an error condition.
!
TABLE
dt   oxy       bod       oxysat    h         k         ka        oxymin    time
0.1  10        1         10        10        0.1       1.0       10.0      2.0
1.0  10        1         10        10        0.1       1.0       ?         ?
!
! This case is unacceptable: time step must be positive
0.0  ?         ?         ?         ?         ?         ?         ?         ERROR
1.0  0.        10        10        10        0.1       1.0       ?         ?
</pre>
</div>
<div id="section6" class="doctools_section"><h2><a name="section6">TODO</a></h2>
<p>The following things are still left to do:</p>
<ul class="doctools_itemized">
<li><p>Proper inclusion of the routine <em>prolog</em> and <em>epilog</em></p></li>
<li><p>Extension of the set of assertion routines</p></li>
</ul>
</div>
<div id="section7" class="doctools_section"><h2><a name="section7">RELATED WORK</a></h2>
<p>There are at least two similar initiatives with regard to a unit testing
framework for Fortran:</p>
<ul class="doctools_itemized">
<li><p><a href="http://nasarb.rubyforge.org">Funit (implemented in Fortran and
Ruby)</a> by Bil Kleb and others</p></li>
<li><p><a href="http://www.sourceforge.net/projects/pfunit">A framework
implemented in Fortran</a> by Brice Womack and Tom Clune</p></li>
<li><p><a href="http://www.sourceforge.net/projects/fortranxunit">FRUIT
(implemented in Fortran and Ruby)</a> by Andrew Chen</p></li>
</ul>
<p>(Note: To avoid confusion, I have renamed my original module &quot;funit&quot; to
<em>ftnunit</em>)</p>
</div>
<div id="copyright" class="doctools_section"><h2><a name="copyright">Copyright</a></h2>
<p>Copyright &copy; 2009 Arjen Markus &lt;arjenmarkus@sourceforge.net&gt;</p>
</div>
</div></body></html>
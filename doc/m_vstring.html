
<html><head>
<title>flibs/m_vstrings - flibs </title>
</head>
<! -- Generated from file 'm_vstring.man' by tcllib/doctools with format 'html'
   -->
<! -- Copyright &copy; 2008 Michael Baudin michael.baudin@gmail.com
   -->
<! -- CVS: $Id$ flibs/m_vstrings.n
   -->

<body>
<h1> flibs/m_vstrings(n) 1.0  &quot;flibs&quot;</h1>
<h2><a name="name">NAME</a></h2>
<p>
<p> flibs/m_vstrings - Processing strings




<h2><a name="table_of_contents">TABLE OF CONTENTS</a></h2>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#table_of_contents">TABLE OF CONTENTS</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#synopsis">SYNOPSIS</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#description">DESCRIPTION</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#overview">OVERVIEW</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#creating_a_string">Creating a string</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#concatenate_two_strings">Concatenate two strings</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#modify_the_case">Modify the case</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pattern_matching">Pattern matching</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#validating_a_string">Validating a string</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#allocatable_or_pointer">Allocatable or pointer</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#dynamic_or_static_buffer">Dynamic or static buffer</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#limitations">Limitations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#preprocessing">Preprocessing</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#history">History</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#methods">METHODS</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#copyright">COPYRIGHT</a><br>
<h2><a name="synopsis">SYNOPSIS</a></h2>
<p>
<table border=1 width=100% cellspacing=0 cellpadding=0><tr            bgcolor=lightyellow><td bgcolor=lightyellow><table 0 width=100% cellspacing=0 cellpadding=0><tr valign=top ><td ><a href="#1"><strong>vstring_new</strong> <i class='arg'>(this ?args?)</i></a></td></tr>
<tr valign=top ><td ><a href="#2"><strong>vstring_new</strong> <i class='arg'>(this)</i></a></td></tr>
<tr valign=top ><td ><a href="#3"><strong>vstring_new</strong> <i class='arg'>(this,char_string)</i></a></td></tr>
<tr valign=top ><td ><a href="#4"><strong>vstring_new</strong> <i class='arg'>(this,vstring)</i></a></td></tr>
<tr valign=top ><td ><a href="#5"><strong>vstring_new</strong> <i class='arg'>(this,chararray)</i></a></td></tr>
<tr valign=top ><td ><a href="#6"><strong>vstring_new</strong> <i class='arg'>(this,ncount ?,vstring?)</i></a></td></tr>
<tr valign=top ><td ><a href="#7"><strong>vstring_free</strong> <i class='arg'>(this)</i></a></td></tr>
<tr valign=top ><td ><a href="#8"><strong>vstring_exists</strong> <i class='arg'>(this)</i></a></td></tr>
<tr valign=top ><td ><a href="#9"><strong>vstring_equals </strong> <i class='arg'>(this, stringb ?nocase,length?)</i></a></td></tr>
<tr valign=top ><td ><a href="#10"><strong>vstring_equals </strong> <i class='arg'>(this, stringb ?nocase,length?)</i></a></td></tr>
<tr valign=top ><td ><a href="#11"><strong>vstring_cast</strong> <i class='arg'>(this, ?args?)</i></a></td></tr>
<tr valign=top ><td ><a href="#12"><strong>vstring_cast</strong> <i class='arg'>(this,length,charstring)</i></a></td></tr>
<tr valign=top ><td ><a href="#13"><strong>vstring_cast</strong> <i class='arg'>(this,charstring)</i></a></td></tr>
<tr valign=top ><td ><a href="#14"><strong>vstring_length</strong> <i class='arg'>(this)</i></a></td></tr>
</table></td></tr></table>
<h2><a name="description">DESCRIPTION</a></h2>
<p>

The module <em>m_vstring</em> provides services to manage strings of dynamic length.
The goal of the current component is to provide higher-level
services that the standard fortran currently provides,
considering Tcl as a model for string management.
It provides string comparison, string search and string
matching methods.
See in test_m_vstring to see a complete example of the
services provided.

<h2><a name="overview">OVERVIEW</a></h2>
<p>
  A vstring is an array of characters. 
  The simplest way to create a vstring is with vstring_new 
  from a &quot;character(len=&lt;something&gt;)&quot; string.
  The length of the vstring is computed dynamically,
  depending on the current number of characters, with vstring_length.
  In the following example, the length is 9.
 
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    use m_vstring, only : &amp;
      vstring_new, &amp;
      vstring_free, &amp;
      t_vstring, &amp;
      vstring_length
    type ( t_vstring,) :: string1
    integer :: length
    call vstring_new ( string1 , &quot;my string&quot; )
    length = vstring_length (string1)
    call vstring_free( string1 )
</pre></td></tr></table></p>

<h3><a name="creating_a_string">Creating a string</a></h3>
<p>
  With vstring_new, one can also create a new vstring as a copy 
  of an existing vstring.
  With vstring_new, one can also create a new vstring with an 
  array of characters or with a repeated copy of an existing vstring.
  Destroy the vstring with vstring_free.

<h3><a name="concatenate_two_strings">Concatenate two strings</a></h3>
<p>
  
  Two vstrings can be concatenated in two ways.
  The vstring_concat method returns a new vstring computed by the 
  concatenation of the two strings.
  The vstring_append allows to add the characters of the 2nd vstring
  at the end of the current string.
  In the following example, the string3 is &quot;my string is very interesting&quot;.

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    call vstring_new ( string1 , &quot;my string&quot; )
    call vstring_new ( string2 , &quot; is very interesting&quot; )
    string3 = vstring_concat ( string1 , string2 )
</pre></td></tr></table></p>

<h3><a name="modify_the_case">Modify the case</a></h3>
<p>
  
  The user can modify the case of a vstring.
  The vstring_tolower creates a new vstring with lower case characters.
  The vstring_toupper creates a new vstring with upper case characters.
  The vstring_totitle creates a new vstring with the first letter in
  upper case and all the other characters to lower case.

  The user can know if two vstrings are equal with vstring_equals.
  Two vstrings can be compared with vstring_compare, which 
  is based on the lexicographic order.

  One can transform one vstring into a new one using a map with
  vstring_map.

<h3><a name="pattern_matching">Pattern matching</a></h3>
<p>
  
  The vstring_match method provides string-matching services in the glob-style.
  It manages &quot;*&quot; pattern (which matches 0 or more characters), 
  the &quot;?&quot; pattern (which matches exactly one character),
  escape sequences and character ranges.
  The following example show how to compare a file name against a pattern :

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    call vstring_new ( string1 , &quot;m_vstring.f90&quot; )
    call vstring_new ( pattern , 'm_*.f90' )
    match = vstring_match ( string1 , pattern )
</pre></td></tr></table></p>

<h3><a name="validating_a_string">Validating a string</a></h3>
<p>
  
  The vstring_is method provides a way of validating data by 
  computing whether the vstring is in a class of data, for example 
  integer, real, digit, alphanumeric, etc...
  In the following example, the user can check whether the 
  string read on standard input is an integer :

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    read ( 5 , * ) charstring
    call vstring_new ( string1 , charstring )
    isinteger = call vstring_is ( string1 , &quot;integer&quot; )
    if ( .NOT. isinteger ) then
      ! Generate an error
    endif
</pre></td></tr></table></p>

  If the character set under use is not in one the pre-defined classes 
  of vstring_is, the user can directly call vstring_isincharset or 
  vstring_isinasciirange, which are the basic blocks of vstring_is.

  Second string argument may be character string
  The design choice has been made to design the subroutines/functions
  so that their dummy arguments are generally only of type t_vstring.
  Another choice would have been to allways take as dummy arguments both
  t_vstring and &quot;character (len=*)&quot; strings, with module procedure 
  interfaces to make them generic.
  The last choice ease the work of the client of the current component,
  which can use directly standard fortran constant strings (for example,

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    equals = vstring_equals ( string1 , &quot;toto&quot; )
</pre></td></tr></table></p>

  instead of

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    type ( t_vstring ) :: string2
    call vstring_new ( string2 , &quot;toto&quot; )
    equals = vstring_equals ( string1 , string2 )
    call vstring_free ( string2 )
</pre></td></tr></table></p>

  that is to say 5 lines instead of 1.

  The main drawback is that the number of interfaces is at least 
  multiplied by 2, if not 4 or 8 when the number of string arguments is more 
  than 2. This makes the unit tests multiplied by the same number, if one 
  want to exercise all the possible interfaces. That way was chosen
  by the original iso_varying_string module and lead to a heavy component,
  with a large number of lines and a small number of features, because 
  all the time was lost in the management of such an heavy module.
  The other drawback is that is breaks the object oriented design
  so that the &quot;type bound&quot; procedure of F2003 cannot be used.
  The current choice is to focus mainly on the services provided,
  not the ease of use. That allows to provide much more features than
  in the original component, but complicates a little more the 
  use in the client code. 
  The choice done here is that the first argument is allways of type 
  vstring (and called &quot;this&quot;), while the second argument (if any), mays 
  by either of type vstring or of type &quot;character (len=*).
  That solution allows to keep both consistency and ease of use at 
  the maximum possible level.
  Several methods are designed this way, for example, vstring_equals, 
  vstring_compare, vstring_append, vstring_concat and others.

<h3><a name="allocatable_or_pointer">Allocatable or pointer</a></h3>
<p>
  Two implementation of m_vstring are provided, depending on the compiler used :
<ul>
<li> the allocatable array of characters with the pre-processing macro _VSTRING_ALLOCATABLE,
<br><br>
<li>  the pointer array of characters with the pre-processing macro _VSTRING_POINTER
</ul>
  If none of the macros are defined, the default implementation is _VSTRING_ALLOCATABLE.
  The two implementations provide exactly the same services.
  But the &quot;allocatable&quot; implementation allows to manage the vstring
  which are going out of the current scope so that the use of vstring_free
  is not necessary and memory leaks do not occur.
  Instead, with the pointer implementation, the call to vstring_free is 
  strictly necessary (if not, memory is lost each time a new vstring is
  created).
  The current version of m_vstring has been tested with the 
  following compilers and versions:
<ul>
<li> Intel Visual Fortran 8 : tested with _VSTRING_ALLOCATABLE and _VSTRING_POINTER
      But the allocatable version allows to debug more easily.
<br><br>
<li> gfortran 2007/04/16 : tested with _VSTRING_POINTER (works fine,
      except for vstring_match)
<br><br>
<li> g95 May  3 2007 : tested with _VSTRING_POINTER, OK
</ul>

<h3><a name="dynamic_or_static_buffer">Dynamic or static buffer</a></h3>
<p>
  
  The internal algorithms provided by m_vstrings are based on 
  basic fortran character strings. In several situations, the 
  dynamic vstring has to be converted into a basic fortran character
  buffer string, which size has to be given explicitely in the source 
  code, with the len = &lt;something&gt; statement (in the 
  character ( len = &lt;something&gt;) ). Two solutions are provided, 
  and the user can define the pre-processing macro 
  _VSTRING_STATIC_BUFFER to configure that :
<ul>
<li> the first solution is to set the size of the buffer statically,
    to a constant integer value VSTRING_BUFFER_SIZE.
  <br><br>
<li> the second solution is to compute the size 
    of the buffer dynamicaly, with the fortran 90 len = vstring_length(this)
    statement,
</ul>
  If the _VSTRING_STATIC_BUFFER is defined, then character strings of 
  constant size are used as buffers.
  If the _VSTRING_STATIC_BUFFER is not defined (which is the default), 
  then character strings of dynamic size are used as buffers.
  The second solution is more efficient, because the strings are not 
  oversized or undersized, depending on the real number of characters
  in the dynamic string. But the feature may not be provided 
  by the compiler at hand. For example, problems with the dynamic 
  length character string have been experienced with Intel Fortran 8.

<h3><a name="limitations">Limitations</a></h3>
<p>
<ul>
<li> No regular expression algorithm is provided.
      But vstring_match allows to do string matching in glob-style.
    <br><br>
<li> The vstring_match does not work with gfortran 2007/04/16 because 
      of a limitation in gfortran for zero-size arrays
    <br><br>
<li> the vstring_adjustl, vstring_adjustr, vstring_scan, 
      vstring_adjustl, vstring_adjustr, vstring_is methods does not
      work with IVF8 because strings declared like this :
        character (len = vstring_length(this) :: character
      are not consistent strings, probably because of a bug
      in the implementation of len = pure function value in IVF8.
    <br><br>
<li> Fortran does not allow to manage character encodings such as UTF8.
</ul>

<h3><a name="preprocessing">Preprocessing</a></h3>
<p>
  The following preprocessing macro must be considered :
<ul>
<li>  _VSTRING_STATIC_BUFFER : see  the section &quot;Dynamic or static buffer&quot;
<br><br>
<li> _VSTRING_ALLOCATABLE or _VSTRING_POINTER : see the section &quot;Allocatable or pointer&quot;
</ul>

<h3><a name="history">History</a></h3>
<p>
   This module was originally based on the iso_varying_string.f90 module 
   by Rich Townsend.


<h2><a name="methods">METHODS</a></h2>
<p>

<dl>

<dt><a name="1"><strong>vstring_new</strong> <i class='arg'>(this ?args?)</i></a><dd>


Generic constructor. Creates the new vstring &quot;this&quot;.

<br><br>
<dt><a name="2"><strong>vstring_new</strong> <i class='arg'>(this)</i></a><dd>

Creates a vstring with 0 characters and 0 length.

<br><br>
<dt><a name="3"><strong>vstring_new</strong> <i class='arg'>(this,char_string)</i></a><dd>

<dl>
<dt>character(LEN=*), intent(in) :: <i class='arg'>char_string</i><dd>
</dl>
The new vstring is filled with the 
characters found in &quot;char_string&quot;.

<br><br>
<dt><a name="4"><strong>vstring_new</strong> <i class='arg'>(this,vstring)</i></a><dd>

<dl>
<dt>type ( t_vstring ) , intent(in) :: <i class='arg'>vstring</i><dd>
</dl>
The new vstring is filled with the 
characters found in the dynamic string &quot;vstring&quot;.

<br><br>
<dt><a name="5"><strong>vstring_new</strong> <i class='arg'>(this,chararray)</i></a><dd>

<dl>
<dt>character(len=1), dimension(:), intent(in) :: <i class='arg'>chararray</i><dd>
</dl>
The new vstring is filled with the 
characters found in the array of characters &quot;chararray&quot;.

<br><br>
<dt><a name="6"><strong>vstring_new</strong> <i class='arg'>(this,ncount ?,vstring?)</i></a><dd>

<dl>
<dt>integer, intent(in) :: <i class='arg'>ncount</i><dd>
<dt>type ( t_vstring ) , intent(in), optional :: <i class='arg'>vstring</i><dd>
</dl>
Repeat the string ncount times and concatenate the result to create the new string.
If not provided, the default string is the blank space.
This can be considered as an implementation of &quot;vstring_repeat&quot;.

<br><br>
<dt><a name="7"><strong>vstring_free</strong> <i class='arg'>(this)</i></a><dd>

Destructor.
<br><br>
     The use of the destructor is OPTIONAL.
     See the thread &quot; New ISO_VARYING_STRING implementation 
     (without memory leaks)&quot; on comp.lang.fortran :
     &quot;On most systems, memory is memory :-).  However, there is a
     difference between how ALLOCATABLE variables and POINTER
     variables are handled.  ALLOCATABLE variables are always
     deallocated automatically when thay go out of scope (unless
     they have the SAVE attribute).  POINTER variables usually
     are not.  The reason is that the program may have associated
     additional pointers, that aren't going out of scope, with the
     same target as the one that is.&quot;

<br><br>
<dt><a name="8"><strong>vstring_exists</strong> <i class='arg'>(this)</i></a><dd>

Returns .true. if the string is allocated.

<br><br>
<dt><a name="9"><strong>vstring_equals </strong> <i class='arg'>(this, stringb ?nocase,length?)</i></a><dd>

<dl>
<dt>type ( t_vstring ) , intent(in) :: <i class='arg'>stringb</i><dd>
<dt>logical , intent (in), optional :: <i class='arg'>nocase</i><dd>
<dt>integer , intent ( in ), optional :: <i class='arg'>length</i><dd>
</dl>
     Perform a character-by-character comparison of strings this and stringb.
     Returns true if this and string2 are identical, or .false when not.
     If nocase is set to true, the case of the characters is not taken into account.
     The default behaviour is to take into account for case of characters.
     If length is specified, then only the first length characters are used in the comparison.

<br><br>
<dt><a name="10"><strong>vstring_equals </strong> <i class='arg'>(this, stringb ?nocase,length?)</i></a><dd>

<dl>
<dt>character(len=*), intent(in) :: <i class='arg'>string_b</i><dd>
<dt>logical , intent (in), optional :: <i class='arg'>nocase</i><dd>
<dt>integer , intent ( in ), optional :: <i class='arg'>length</i><dd>
</dl>
     Same as previous.

<br><br>
<dt><a name="11"><strong>vstring_cast</strong> <i class='arg'>(this, ?args?)</i></a><dd>

Convert a varying string into a character string.

<br><br>
<dt><a name="12"><strong>vstring_cast</strong> <i class='arg'>(this,length,charstring)</i></a><dd>

<dl>
<dt>integer, intent(in) :: <i class='arg'>length</i><dd>
<dt>character ( LEN = length ) , intent(out) :: <i class='arg'>charstring</i><dd>
</dl>
Convert a varying string into a character string
with fixed length.
If the number of characters in the target charstring
is not large enough, the target charstring is truncated, that is,
contains only the first characters of the current dynamic string.

<br><br>
<dt><a name="13"><strong>vstring_cast</strong> <i class='arg'>(this,charstring)</i></a><dd>

<dl>
<dt>character ( LEN = * ) , intent(out) :: <i class='arg'>charstring</i><dd>
</dl>
Convert a varying string into a character string
with automatic length.
If the number of characters in the target charstring
is not large enough, the target charstring is truncated, that is,
contains only the first characters of the current dynamic string.

<br><br>
<dt><a name="14"><strong>vstring_length</strong> <i class='arg'>(this)</i></a><dd>

Returns the length of the current dynamic string.


</dl>




<h2><a name="copyright">COPYRIGHT</a></h2>
<p>
Copyright &copy; 2008 Michael Baudin michael.baudin@gmail.com<br>
</body></html>
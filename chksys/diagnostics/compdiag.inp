! compdiag.inp --
!     File with the code for the test programs that are used
!     to analyse the behaviour of the compiler
!     Each test program should be documented using:
!     @desc - short textutal description (also start of
!             new test program)
!     @category - one of:
!              basic     - basic checks of certain aspects
!              medium    - checks that require more analysis
!              advanced  - checks for trickier aspects
!              extension - checks whether popular extensions are
!                          supported
!              f2003     - checks for Fortran 2003 features
!
!              Note that the categories basic, medium and advanced
!              are fairly subjective.
!

@desc Does the compiler check the values of keywords to OPEN
@category basic
program check
    open( 10, file = 'check.inp', form = 'nonsense' )
end program

@desc Does the compiler accept FORM="BINARY"
@category extension
program check
    open( 10, file = 'check.inp', form = 'binary' )
end program

@desc Function that does not set the value
@category basic
real function check( x )
    real :: x
end function check

@desc Function that does not always set the value
@category medium
real function check( x )
    real :: x
    if ( x > 0 ) then
        check = 2.0
    endif
end function check

@desc Using function variable before it is set
@category medium
real function check( x )
    real :: x
    if ( check > 0 ) then
        check = 2.0 * x
    endif
end function check

@desc Unused argument in subroutine
@category medium
subroutine check( x )
    real :: x
    real :: y

    y = 10.0
end subroutine check

@desc Tabs are accepted
@category extension
program check
	write(*,*)	'Tabs allowed'
end program check

@desc Interface required because of optional arguments
@category basic
subroutine check( x, opt )
    real :: x
    logical, optional :: opt
    logical :: opt_
    opt_ = .false.
    if ( present(opt) ) then
        opt_ = opt
    endif
    if ( opt_ ) then
        write(*,*) 'X: ', x
    else
        write(*,*) x
    endif
end subroutine check

@desc Interface required because of pointer arguments
@category basic
subroutine check( x )
    real, pointer, dimension(:) :: x
    write(*,*) x
end subroutine check

@desc Interface required because of assumed shape arguments
@category basic
subroutine check( x )
    real, dimension(:) :: x
    write(*,*) x
end subroutine check

@desc Using a real as the control variable of a DO loop
@category basic
program check
    real :: x

    do x = 0.1,1.0,0.1
        write(*,*) x
    enddo
end program check

@desc Duplicate case in SELECT block
@category basic
program check
    integer :: x

    do x = 1,10
        select case ( x )
            case( 1, 2, 3 )
                write(*,*) x
            case( 3 )
                write(*,*) x
            case default
                write(*,*) x
        end select
    enddo
end program check

@desc Duplicate case in SELECT block - same case
@category basic
program check
    integer :: x

    do x = 1,10
        select case ( x )
            case( 1, 1, 3 )
                write(*,*) x
            case( 4 )
                write(*,*) x
            case default
                write(*,*) x
        end select
    enddo
end program check

@desc Missing default case in SELECT block - defensive programming
@category advanced
program check
    integer :: x

    do x = 1,10
        select case ( x )
            case( 1, 2, 3 )
                write(*,*) x
            case( 4 )
                write(*,*) x
        end select
    enddo
end program check

@desc Uninitialised variable used - defensive programming
@category basic
program check
    integer :: x
    integer :: y

    y = x
end program check

@desc Mismatch in static shapes of arrays - assignment
@category basic
program check
    integer, dimension(4) :: x
    integer, dimension(5) :: y

    x = 1
    y = x
end program check

@desc Mismatch in static shapes of arrays - merge function
@category basic
program check
    integer, dimension(4) :: x
    integer, dimension(5) :: y
    logical, dimension(5) :: z
    x = 1
    z = .true.
    write(*,*) merge( x, y, z )
end program check

@desc Mismatch in static shapes of arrays - user-defined function
@category advanced
program check
    integer, dimension(4) :: x
    integer, dimension(5) :: y
    x = 1
    y = f(x)
contains
function f( x )
    integer, dimension(:) :: x
    integer, dimension(size(x)) :: f
    f = x
end function f
end program check

@desc Accepting different string lengths in array constructor
@category extension
program check

    write(*,*) (/ 'A', 'BBB' /)
end program check

@desc Accepting square brackets in array constructor
@category f2003
program check

    write(*,*) [ 1, 2, 3 ]
end program check

@desc Accepting different string lengths in MERGE function
@category extension
program check

    logical :: cond

    cond = .false.
    write(*,*) merge( 'true', 'false', cond )
end program check

@desc Accepting different numerical types in MERGE function
@category basic
program check

    logical :: cond

    ! There is no sensible type for the result!
    cond = .false.
    write(*,*) merge( 1, 2.0, cond )
end program check

@desc Violating intent() constraint - input only
@category basic
subroutine check( x )
    real, intent(in) :: x

    x = 2.0
end subroutine check

@desc Violating intent() constraint - output only
@category basic
subroutine check( x )
    real, intent(out) :: x

    ! x not set
end subroutine check

@desc Violating intent() constraint - checking output only variable before set
@category medium
subroutine check( x )
    real, intent(out) :: x

    ! x not yet set
    if ( x > 0.0 ) then
        write(*,*) 'x positive'
    endif
    x = -1.0
end subroutine check

@desc Allocatable arguments to a subroutine
@category f2003
program checkit
    real, allocatable, dimension(:) :: x

    call check( x )
contains
subroutine check( x )
    real, allocatable, dimension(:) :: x

    allocate( x(10) )
end subroutine check
end program checkit

@desc Allocatable components in a derived type
@category f2003
program check
    type allocs
        real, allocatable, dimension(:) :: x
    end type allocs

    type(allocs) :: value
end program check

@desc Integer overflow at compile time
@category basic
program check
    integer :: y

    y = 2 * huge(1)
end program check

@desc Transcendental functions in parameter statement
@category extension
program check
    real, parameter :: x = sin(1.0)
end program check

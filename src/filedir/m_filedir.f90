!
! m_filedir.f90 --
!   Manipulate file and directory names
!
!   The module contains the following functions:
!   filedir_rootname       Return the name without an extension
!   filedir_extension      Return the extension
!   filedir_tail       Return the name without the directory (if present)
!   filedir_dirname        Return the directory name
!   filedir_join         Concatenate a directory name and a file name
!   filedir_add_extension  Add an extension to a file name
!
!   The functions actually perform fairly simple string manipulations.
!   It is just that these manipulations occur frequently.
!
!   $Id$
!
module m_filedir
  use m_platform, only : &
       platform_get_platform, &
       platform_system, &
       PLATFORM_PLATFORM_WINDOWS, &
       PLATFORM_PLATFORM_UNIX, &
       PLATFORM_PLATFORM_MAC, &
       PLATFORM_PLATFORM_NB, &
       platform_get_environment_variable , &
       platform_cd, &
       platform_stat
  implicit none
  private
  public :: filedir_add_extension
  public :: filedir_atime
  public :: filedir_copy
  public :: filedir_copy_std
  public :: filedir_delete
  public :: filedir_dirname
  public :: filedir_exists
  public :: filedir_extension
  public :: filedir_findByPattern
  public :: filedir_first_separator_index
  public :: filedir_get_unit
  public :: filedir_init
  public :: filedir_isdirectory
  public :: filedir_join
  public :: filedir_last_separator_index
  public :: filedir_mkdir
  public :: filedir_mtime
  public :: filedir_nativename
  public :: filedir_normalize
  public :: filedir_pathtype
  public :: filedir_pwd
  public :: filedir_rename
  public :: filedir_rootname
  public :: filedir_separator
  public :: filedir_split
  public :: filedir_tail
  public :: filedir_tempdir
  public :: filedir_tempfile
  public :: filedir_touch
  !
  ! Static attributes
  !
  ! Maximum number of columns in a text file
  integer, parameter, public :: MAX_COLUMNS_TEXT = 1000
  ! Maximum number of units when searching for an unused file unit
  integer, parameter, public :: MAX_UNIT_NUMBER = 1000
  ! Maximum string length for the error messages generated by the file subroutines
  integer, parameter, public :: MAX_COMMAND_LENGTH = 1000
  character (len=1), parameter :: PLATFORM_SEPARATOR_UNKNOWN = "?"
  character (len=1), save :: PLATFORM_SEPARATOR = PLATFORM_SEPARATOR_UNKNOWN
  !
  ! Static, Platform-specific commands
  !
  character(len=20), save :: command_ls
  character(len=20), save :: command_copy
  character(len=20), save :: command_mkdir
  character(len=20), save :: command_redirect
  character(len=20), save :: command_suppress_msg
  character(len=20), save :: command_touch
  character(len=20), save :: command_rmdir
  character(len=20), save :: command_rmdir_force
  ! Set to .true. if the static attributes have allready been initialized
  logical :: filedir_static_initialized = .false.
  !
  ! Tags for path types
  !
  integer, parameter, public :: FS_PATHTYPE_ABSOLUTE = 1
  integer, parameter, public :: FS_PATHTYPE_RELATIVE = 2
  integer, parameter, public :: FS_PATHTYPE_VOLUMERELATIVE = 3
  interface filedir_delete
     module procedure filedir_delete_with_force
     module procedure filedir_delete_without_force
  end interface filedir_delete
  !
  ! Tags to manage errors.
  !
  integer , parameter, public :: FS_OK = 0
  integer , parameter, public :: FS_UNABLE_TO_OPEN_SOURCE = 1
  integer , parameter, public :: FS_UNABLE_TO_OPEN_TARGET = 2
  integer , parameter, public :: FS_UNABLE_TO_WRITE_TARGET = 3
  integer , parameter, public :: FS_SOURCE_FILE_DOES_NOT_EXIST = 4
contains
  !
  ! filedir_init --
  !   Initialize module internal state.
  ! Arguments:
  !   no argument
  subroutine filedir_init ( )
    integer :: platform
    character (len=200) :: message
    if (.NOT.filedir_static_initialized) then
       !
       ! 0. Get the current platform
       !
       platform = platform_get_platform ()
       !
       ! 1. Initialize the platform-specific separator
       !
       ! Setup the separator depending on the platform
       select case ( platform )
       case ( PLATFORM_PLATFORM_WINDOWS )
          PLATFORM_SEPARATOR = "\"
       case ( PLATFORM_PLATFORM_UNIX )
          PLATFORM_SEPARATOR = "/"
       case ( PLATFORM_PLATFORM_MAC )
          PLATFORM_SEPARATOR = ":"
       case default
          write(message,*) "Unknown separator for platform :", platform
          call filedir_error ( "filedir_init" , message )
       end select
       !
       ! 2. Initialize the platform-specific commands
       !
       select case ( platform )
       case ( PLATFORM_PLATFORM_WINDOWS )
          ! See http://en.wikipedia.org/wiki/List_of_DOS_commands
          command_ls = "dir /b"
          command_copy = "copy"
          command_mkdir = "mkdir"
          command_redirect = ">"
          command_suppress_msg = "2>nul"
          command_touch = ""
          command_rmdir = "rd"
          command_rmdir_force = "rmdir /s /q"
       case ( PLATFORM_PLATFORM_UNIX )
          ! See http://en.wikipedia.org/wiki/List_of_Unix_programs
          command_ls = "ls"
          command_copy = "cp"
          command_mkdir = "md"
          command_redirect = ">"
          command_suppress_msg = "2>/dev/null"
          command_touch = "touch"
          command_rmdir = "rm"
          command_rmdir_force = "rm -r -f"
       case default
          write(message,*) "Unknown commands for platform :", platform
          call filedir_error ( "filedir_init" , message )
       end select
       !
       ! Update the static flag
       !
       filedir_static_initialized = .true.
    endif
  end subroutine filedir_init
  !
  ! filedir_rootname --
  !   Return the name without the extension (if any)
  ! Arguments:
  !   filename   Name of the file to be examined
  ! Result:
  !   The part of the name _before_ the last "." or the whole name
  !   if no "." is present
  !
  function filedir_rootname ( filename ) result (rootname)
    character(len=*), intent(in)             :: filename
    character(len=len(filename)) :: rootname
    integer                      :: kdot
    integer                      :: kseparator
    kdot   = scan( filename, '.', .true. )
    kseparator = filedir_last_separator_index ( filename )
    rootname = filename
    if ( kdot .ne. 0 .and. kdot .gt. kseparator+1 ) then
       rootname = filename(1:kdot-1)
    endif
  end function filedir_rootname
  !
  ! filedir_extension --
  !   Return the extension (if any)
  ! Arguments:
  !   filename   Name of the file to be examined
  ! Result:
  !   The part of the name _after_ and including the last "." or empty if none
  !   present
  ! Example : if filename is "declaration.txt", the file extension is ".txt".
  !
  function filedir_extension ( filename ) result (extension)
    character(len=*), intent(in)             :: filename
    character(len=len(filename)) :: extension
    integer                      :: kdot
    integer                      :: kseparator
    kdot   = scan( filename, '.', .true. )
    kseparator = filedir_last_separator_index ( filename )
    extension = ''
    if ( kdot .ne. 0 .and. kdot .gt. kseparator+1 ) then
       extension = filename(kdot:)
    endif
  end function filedir_extension
  !
  ! filedir_tail --
  !   Returns all of the characters in name after the last directory separator
  ! Arguments:
  !   filename   Name of the file to be examined
  ! Result:
  !   Returns all of the characters in name after the last directory separator
  !   If name contains no separators then returns name.
  !
  function filedir_tail ( filename ) result (basename)
    character(len=*), intent(in)             :: filename
    character(len=len(filename)) :: basename
    integer                      :: kseparator
    kseparator = filedir_last_separator_index ( filename )
    basename = filename
    if ( kseparator .gt. 1 ) then
       basename = filename(kseparator+1:)
    endif
  end function filedir_tail
  !
  ! filedir_dirname --
  !   Return the directory (if any)
  ! Arguments:
  !   filename   Name of the file to be examined
  ! Result:
  !   The part of the name _before_ the last directory separator
  !
  function filedir_dirname( filename ) result (dirname)
    character(len=*), intent(in)             :: filename
    character(len=len(filename)) :: dirname
    integer                      :: kseparator
    kseparator = filedir_last_separator_index ( filename )
    dirname = ''
    if ( kseparator .gt. 1 ) then
       dirname = filename(1:kseparator)
    endif
  end function filedir_dirname
  !
  ! filedir_last_separator_index --
  !   Returns the index of the last separator in the given filename
  !   or 0 if there is no separator in the given file name.
  ! Arguments:
  !   filename   Name of the file to be examined
  !
  integer function filedir_last_separator_index ( filename )
    character (len=1) :: separator
    character(len=*), intent(in)             :: filename
    logical , parameter :: backward = .true.
    separator = filedir_separator ()
    filedir_last_separator_index = scan( filename, separator , backward )
  end function filedir_last_separator_index
  !
  ! filedir_join --
  !   Return the directory plus the file
  ! Arguments:
  !   directory  Name of the directory to be used
  !   filename   Name of the file to be used
  ! Result:
  !   Concatenated directory and file names
  !
  function filedir_join ( directory, filename ) result (fullname)
    character(len=*),intent(in)             :: directory
    character(len=*),intent(in)             :: filename
    character(len=len(directory)+len(filename)+1) :: fullname
    fullname = trim(directory) // filedir_separator () // filename
  end function filedir_join
  !
  ! filedir_add_extension --
  !   Return a new file name with the given extension concatenated.
  !   If the given file name ends with a dot and the given extension begins
  !   with a dot, only one dot is kept.
  ! Arguments:
  !   filename   Name of the file to be used
  !   extension  Extension to be added (e.g. ".txt")
  ! Result:
  !   The file name with an added extension
  ! Note :
  !   The extension of one file begins with a dot : ".txt" is a file
  !   extension while "txt" is not.
  !
  function filedir_add_extension ( filename , extension ) result (newname)
    character(len=*), intent(in)             :: filename
    character(len=*), intent(in)             :: extension
    ! Caution !
    ! The length of the new file is greater that the length of the original file !
    ! This is why the logic must be kept simple :
    ! if one takes into account that the extension may or may not include
    ! 1 dot, the length of the new file is not predictible, that is
    ! may be len(filename)+len(extension) or len(filename)+len(extension) + 1,
    ! which would lead to memory errors if the file names have just the right size.
    character(len=len(filename)+len(extension)) :: newname
    integer :: kdot
    integer :: length_trimmed
    kdot    = index( filename , '.', .true. )
    length_trimmed = len_trim(filename)
    if ( kdot == length_trimmed ) then
       ! The file name ends with a dot, so we do not add one.
       newname = trim(filename(1:kdot-1))//trim(extension)
    else
       newname = trim(filename)//trim(extension)
    endif
  end function filedir_add_extension
  !
  ! filedir_rename --
  !   Renames the file ofdln to newfn by using the RENAME fortran extension.
  ! Arguments:
  !   oldfn : the old file name
  !   newfn : the new file name
  !   status, optional : if supplied, it contains 0 on success or nonzero error code
  !     upon return
  !
  subroutine filedir_rename (oldfn, newfn, status )
    character(len=*), intent(in) :: oldfn, newfn
    integer, intent(out) , optional :: status
    ! Caution !
    ! The RENAME subroutine is not in the fortran 90 standard,
    ! but it is an extension in the fortran compilers Intel, G95 and
    ! gfortran. It may generate errors at link time for other
    ! compilers.
    ! In Intel Fortran 8.0, the status optional argument does not exist
    ! If added to the line "call RENAME ( oldfn , newfn , local_status ),
    ! it generates an error at execution time.
    call RENAME ( oldfn , newfn )
    if ( present ( status )) then
       status = 0
    endif
  end subroutine filedir_rename
  !
  ! filedir_copy --
  !   Copy the file ofdln to newfn by using the SYSTEM fortran extension.
  ! Arguments:
  !   sourcefn : the source file name
  !   targetfn : the target file name
  !   status, optional : if supplied, it contains 0 on success or nonzero error code
  !      upon return
  ! Note :
  !    This subroutine is system-dependent.
  !
  subroutine filedir_copy ( sourcefn , targetfn , status )
    character(len=*), intent(in) :: sourcefn, targetfn
    integer, intent(out) , optional :: status
    integer :: local_status
    character (len=len(sourcefn)+len(targetfn)+len(command_copy) + 2) :: command
    character ( len = len(sourcefn)+len(targetfn)+22) :: message
    write ( command , *) trim(command_copy) , " ",  trim(sourcefn), " ", trim(targetfn)
    call platform_system ( command , local_status )
    if ( present ( status )) then
       status = local_status
    elseif ( local_status /=0 ) then
       write(message,*) "Unable to copy :", trim(sourcefn) , " into " , trim(targetfn)
       call filedir_error ( "filedir_copy" , message )
    endif
  end subroutine filedir_copy
  !
  ! filedir_copy_std --
  !   Copy the ascii file ofdln to targetfn by using standard fortran.
  !   If the source file does not exists, generates an error.
  !   If the target file allready exists and force option is undefined
  !   or defined to false, generates an error.
  ! Arguments:
  !   sourcefn : the source file name
  !   targetfn : the target file name
  !   status, optional : if supplied, it contains 0 on success or nonzero error code
  !     upon return
  !    status = 1 when one was unable to open the source file
  !    status = 2 when one was unable to open the target file
  !    status = 3 when there was a problem while writing the target file
  !    status = 4 when the source file does not exist
  !   force, optional : if supplied and true, if the target file allready exists, delete it before
  !                making the copy.
  ! Caution !
  !   1. The maximum number of columns in the source filename is 1000.
  !   2. After execution, the target file is not an exact copy of the source file.
  !   Because of the fortran format used, all the lines of the target file are of length 1000 :
  !   blank spaces are appended at the end of the string.
  !
  !
  subroutine filedir_copy_std ( sourcefn , targetfn , status , force , trimline )
    character(len = *), intent(in) :: sourcefn, targetfn
    integer, intent(out) , optional :: status
    logical, intent(in) , optional :: force
    logical, intent(in), optional :: trimline
    integer :: local_status
    integer :: source_unit, target_unit
    character ( len = MAX_COLUMNS_TEXT ) :: string
    integer :: end_of_file
    logical :: fexist
    character ( len = len(sourcefn)+len(targetfn)+22) :: message
    logical :: trimline_real
    !
    ! Process options
    !
    if ( present ( trimline ) ) then 
       trimline_real = trimline
    else
       trimline_real = .true.
    endif
    !
    ! By default, there is no problem.
    !
    local_status = FS_OK
    !
    ! 0. Check that the source file exist.
    !
    fexist = filedir_exists ( sourcefn )
    if ( .NOT. fexist ) then
       if ( present ( status )) then
          status = FS_SOURCE_FILE_DOES_NOT_EXIST
       else
          write(message,*) "Source file :", trim(sourcefn) , " does not exist."
          call filedir_error ( "filedir_copy_std" , message )
       endif
       return
    endif
    !
    ! 1. If the target file exists, delete it if force = .true.
    !
    if (present ( force )) then
       if (force) then
          fexist = filedir_exists ( targetfn )
          if (fexist) then
             call filedir_delete ( targetfn )
          endif
       endif
    endif
    !
    ! 2. Get two free file units
    !
    source_unit = filedir_get_unit (  )
    open ( UNIT = source_unit , FILE= sourcefn , ACTION='READ',STATUS='OLD', IOSTAT= local_status )
    if ( local_status /=0) then
       local_status = FS_UNABLE_TO_OPEN_SOURCE
    else
       target_unit = filedir_get_unit (  )
       open ( UNIT = target_unit , FILE= targetfn , ACTION='WRITE',STATUS='NEW', IOSTAT= local_status )
       if ( local_status /=0) then
          local_status = FS_UNABLE_TO_OPEN_TARGET
       else
          !
          ! 3. Copy the lines one after another.
          !
          do
             read ( source_unit , '(a)', iostat = end_of_file ) string
             if ( end_of_file /= 0 ) then
                ! The last line has been found.
                exit
             end if
             if ( trimline_real ) then
                write ( target_unit , '(a)', iostat = local_status ) trim(string)
             else
                write ( target_unit , '(a)', iostat = local_status ) string
             endif
             if ( local_status /= 0 ) then
                ! There was an error while writing
                local_status = FS_UNABLE_TO_WRITE_TARGET
                exit
             end if
          enddo
          close ( source_unit )
       endif
       close ( target_unit )
    endif
    if ( present ( status )) then
       status = local_status
    elseif ( local_status /=0 ) then
       write(message,*) "Unable to copy :", trim(sourcefn) , " into " , trim(targetfn)
       call filedir_error ( "filedir_copy_std" , message )
    endif
  end subroutine filedir_copy_std
  !
  ! filedir_get_unit --
  !   Returns a free fortran unit.
  ! Arguments:
  !   no argument
  ! Note :
  !   A "free" FORTRAN unit number is an integer between 1 and MAX_UNIT_NUMBER which
  !   is not currently associated with an I/O device.  A free FORTRAN unit
  !   number is needed in order to open a file with the OPEN command.
  !
  !   If IUNIT = 0, then no free FORTRAN unit could be found, although
  !   all 99 units were checked (except for units 5, 6 and 9, which
  !   are commonly reserved for console I/O).
  !
  !   Otherwise, IUNIT is an integer between 1 and MAX_UNIT_NUMBER, representing a
  !   free FORTRAN unit.  Note that GET_UNIT assumes that units 5 and 6
  !   are special, and will never return those values.
  !
  !  Original Author : John Burkardt
  !
  integer function filedir_get_unit ( )
    integer :: iunit
    integer :: ios
    logical :: lopen
    logical :: unit_found
    iunit = 0
    unit_found = .false.
    filedir_get_unit = 0
    do iunit = 1, MAX_UNIT_NUMBER
       if ( iunit /= 5 .and. iunit /= 6 .and. iunit /= 9 ) then
          inquire ( UNIT = iunit, opened = lopen, iostat = ios )
          if ( ios == 0 ) then
             if ( .not. lopen ) then
                filedir_get_unit = iunit
                unit_found = .true.
                exit
             end if
          end if
       end if
    end do
    if (.NOT.unit_found) then
       call filedir_error ( "filedir_get_unit" , "No unit free." )
    endif
  end function filedir_get_unit
  !
  ! filedir_pwd --
  !   Returns the name of the current directory by using the fortran
  !   extension GETCWD
  ! Arguments:
  !   cwd : the current working directory
  !
  subroutine filedir_pwd ( cwd )
    character(len=*), intent ( out ) :: cwd
    call GETCWD ( cwd )
  end subroutine filedir_pwd
  !
  ! filedir_exists --
  !   Returns .true. if file name exists, .false. otherwise.
  ! Arguments:
  !   filename   Name of the file to be examined
  !
  logical function filedir_exists ( filename )
    character(len=*), intent(in) :: filename
    logical :: fexist
    ! Note :
    ! The other possibility is the ACCESS fortran extension
    ! But the "inquire" intrinsic in fortran standard.
    inquire ( FILE = filename , EXIST = fexist )
    if (fexist) then
       filedir_exists = .true.
    else
       filedir_exists = .false.
    endif
  end function filedir_exists
  !
  ! filedir_delete --
  !   Removes the file or directory specified by each pathname argument. 
  !   Non-empty directories will be removed only if the force option is specified.
  ! Arguments:
  !   filename   Name of the file to be examined
  !   force, optional : if supplied, forces to delete the directory, even if it is empty.
  !   status, optional : if supplied, it contains 0 on success or nonzero error code
  !     upon return
  !
  subroutine filedir_delete_with_force ( filename , force , status )
    character(len=*), intent(in) :: filename
    logical, intent (in) :: force
    integer, intent (out), optional :: status
    integer :: local_status
    integer :: file_unit
    character(len=len(filename)+23) :: message
    logical :: isdir
    ! TODO : this length is ugly, introduce real dynamic strings in fortran 90 OO
    character ( len = len(filename)+len(command_rmdir)+len(command_rmdir_force)+ 1) :: command
    isdir = filedir_isdirectory ( filename )
    if (.NOT.isdir) then
       ! Delete that regular file
       ! One could use the following fortran extension :
       !   call UNLINK ( filename , local_status )
       ! But the following code uses standard fortran statements and therefore
       ! will be full portable.
       file_unit = filedir_get_unit (  )
       open ( UNIT = file_unit , FILE = filename , STATUS ='OLD', IOSTAT= local_status )
       if ( local_status == 0 ) then
          close ( UNIT = file_unit , STATUS = 'DELETE', IOSTAT= local_status )
       endif
    else
       !
       ! Delete that directory
       !
       if (force) then
          write ( command , * ) trim(command_rmdir_force) , " ", trim(filename)
       else
          write ( command , * ) trim(command_rmdir) , " ", trim(filename)
       endif
       call platform_system ( command , local_status )
       isdir = filedir_isdirectory ( filename )
       if (isdir) then
          local_status = -1
       endif
    endif
    if (present ( status )) then
       status = local_status
    elseif ( local_status /=0 ) then
       write(message,*) "Unable to delete file :", trim(filename)
       call filedir_error ( "filedir_delete" , message )
    endif
  end subroutine filedir_delete_with_force
  subroutine filedir_delete_without_force ( filename , status )
    character(len=*), intent(in) :: filename
    integer, intent (out), optional :: status
    logical , parameter :: force = .false.
    call filedir_delete_with_force ( filename , force , status )
  end subroutine filedir_delete_without_force
  !
  ! filedir_atime --
  !   Returns an integer representing the time at which file name was last accessed.
  ! Arguments:
  !   filename : the file name
  !   status, optional : if supplied, it contains 0 on success or nonzero error code
  !   upon return
  ! NOTE :
  !   The CTIME fortran extension is defined in gfortran, in Intel Fortran,
  !   but not in the g95 compiler. So we used the STAT fortran extension :
  !   INTEGER FUNCTION stat(file, sarray)
  !     CHARACTER(LEN=*), INTENT(IN) :: file
  !     INTEGER, INTENT(OUT) :: sarray(13), status
  !   END FUNCTION stat
  !
  integer function filedir_atime ( filename , status )
    character(len=*), intent(in) :: filename
    integer, dimension (1:13) :: statarray
    integer, intent(out) , optional :: status
    integer  :: local_status
    call platform_stat ( filename , statarray , local_status )
    filedir_atime = statarray (9)
    if (present ( status )) then
       status = local_status
    endif
  end function filedir_atime
  !
  ! filedir_mtime --
  !   Returns an integer representing the time at which file name was last modified.
  ! Arguments:
  !   filename : the file name
  !   status, optional : if supplied, it contains 0 on success or nonzero error code
  !   upon return
  integer function filedir_mtime ( filename , status )
    character(len=*), intent(in) :: filename
    integer, dimension (1:13) :: statarray
    integer, intent(out) , optional :: status
    integer  :: local_status
    call platform_stat ( filename , statarray , local_status )
    filedir_mtime = statarray (10)
    if (present ( status )) then
       status = local_status
    endif
  end function filedir_mtime
  !
  ! filedir_separator --
  !   Return the separator for the current platform
  ! Arguments:
  !   no argument
  ! Result:
  !   PLATFORM_SEPARATOR.
  ! Note:
  !   The separator depends on the platform :
  !   - "/" on Unix, Linux systems,
  !   - "\" on Windows systems,
  !   - ":" on Macintosh.
  !
  function filedir_separator ( )
    character :: filedir_separator
    call filedir_init ( )
    filedir_separator = PLATFORM_SEPARATOR
  end function filedir_separator
  !
  ! filedir_normalize --
  !   Returns a unique normalized path representation for the
  !   file-system object (file, directory, link, etc), whose string
  !   value can be used as a unique identifier for it. A normalized path
  !   is an absolute path which has all '../', './' removed. Also it is one which
  !   is in the ``standard'' format for the native platform.
  ! Arguments:
  !   filename   Name of the file to be used
  !   normalized  The normalized file name
  !
  function filedir_normalize ( filename )
    character(len=*), intent(in)             :: filename
    character(len=len(filename))             :: filedir_normalize
    character(len=len(filename)) :: directory
    character(len=len(filename)) :: ftail
    ! TODO : remove the .. and . in the path, based on filedir_split
    ! TODO : replace base separator into native separator
    call filedir_pwd ( directory )
    ftail = filedir_tail ( filename )
    filedir_normalize = filedir_join ( directory , ftail )
  end function filedir_normalize
  !
  ! filedir_error --
  !   Manage an error for the filedir module
  ! Arguments :
  !   origin : the name of the subroutine/function which generated the error.
  !   message : the message to display
  !
  subroutine filedir_error ( origin , message )
    character(len=*), intent(in) :: origin
    character(len=*), intent(in) :: message
    write(6,*) "Internal error from: ", origin
    write(6,*) "Error: ", trim(adjustl(message))
    stop
  end subroutine filedir_error
  !
  ! filedir_findByPattern --
  !   Returns a list of files fulfilling a particular pattern
  !
  ! Arguments:
  !   pattern         Pattern for the file names (like: *.f90)
  !   list            Allocated list of file names (returned)
  !
  ! Note:
  !   The list of files is an allocated array, the caller should
  !   deallocate it when done.
  !   The length of the character strings in list must be long
  !   enough for the file names. Use for instance a length of at
  !   least 200 characters
  !   The list can zero names long, it will still be allocated.
  ! TODO : extend that subroutine so that it can do an optionnal recursive search into the subdirectories.
  !
  subroutine filedir_findByPattern ( pattern , filelength , numberOfFiles , listOfFiles )
    character(len=*), intent(in)            :: pattern
    integer, intent(in) :: filelength
    integer, intent(out)                    :: numberOfFiles
    ! listOfFiles ( : , ifile) is the file #ifile
    ! listOfFiles ( ichar , ifile ) is the character #ichar for file #ifile
    character, dimension(:,:), pointer :: listOfFiles ! -> does not work
!!$    !character(len=*), dimension(:), pointer :: listOfFiles ! -> does not work
!!$    ! NOTE :
!!$    ! When I test it against Intel Fortran 8 or gfortran 4.0.2, the
!!$    ! program freezes. I have to change the declaration of the list of files to :
!!$    !character(len=50), dimension(1:50) :: listOfFiles -> works fine.
!!$    !character(len=*), dimension(1:50) :: listOfFiles -> does not work
!!$    
    character(len=200)                      :: tmpfile
    character(len=200)                      :: cmd
    character(len=1)                        :: line_unused
    integer                                 :: luntmp
    integer                                 :: i
    integer                                 :: ierr
    integer :: platform
    character (len=200) :: tempdir
    character(len=200)             :: prefix
    integer :: ifile
    character (len=filelength) :: current_filename
    character (len=filelength) :: full_filename
    integer :: icharacter
    ! NOTE :
    ! I would like to use this declaration instead, but this does not work ????
    !character(len=len(pattern))             :: prefix
    !
    ! 1. Compute the list of files and redirect it to a temporary file.
    !
    call filedir_tempdir ( tempdir )
    ! TODO  : create a subroutine which returns the path to a temporary file.
    tmpfile = filedir_join ( tempdir , "__filelist__" )
    !
    ! Compute the platform-specific ls command
    !
    ! Only file names!
    ! Get the current platform
    platform = platform_get_platform ()
    cmd = trim(command_ls) // ' ' // trim(pattern) // ' ' // trim(command_redirect) // trim(tmpfile) &
         // ' ' // command_suppress_msg
    ! TODO : understand when the command has to be fixed up with "file_correct_separator"
    !cmd = filedir_normalize ( cmd )
    !
    ! Under windows, we only get the file tails.
    ! So we have to normalize these files tails to get the full file names.
    !
    if (platform == PLATFORM_PLATFORM_WINDOWS) then
       prefix = pattern
       prefix = filedir_normalize ( prefix )
       i = filedir_last_separator_index ( prefix )
       prefix(i:) = ' '
    endif
    call platform_system ( cmd )
    !
    ! 2. Analyse the content of the temporary file.
    !
    luntmp = filedir_get_unit ( )
    open( luntmp , file = tmpfile )
    !
    ! 2.1 Count the number of files, the maximum length of all files
    !
    numberOfFiles = 0
    do
       read( luntmp, '(a)', iostat = ierr ) line_unused
       if ( ierr == 0 ) then
          numberOfFiles = numberOfFiles + 1
       else
          exit
       endif
    enddo
    rewind( luntmp )
    !
    ! 2.2 Fill the array
    !
    allocate( listOfFiles(1:filelength , 1:numberOfFiles ) )
    do ifile = 1 , numberOfFiles
       !read( luntmp, '(a)' ) listOfFiles(ifile,:)
       read( luntmp, '(a)' ) current_filename
       if (platform == PLATFORM_PLATFORM_WINDOWS) then
          full_filename = filedir_join ( prefix , current_filename )
       else
          full_filename = current_filename
       endif
       do icharacter = 1 , filelength
          listOfFiles ( icharacter , ifile ) = full_filename ( icharacter : icharacter )
       enddo
    enddo
    !
    ! 3. Delete the temporary file
    !
    close( luntmp, status = 'delete' )
  end subroutine filedir_findByPattern
  !
  ! filedir_tempdir --
  !   Returns the temporary directory for the current platform.
  !   The command returns the path of a directory where the caller can
  !   place temporary files, such as "/tmp" on Unix systems.
  !   The algorithm we use to find the correct directory is as follows:
  !   1. The directory named in the TMPDIR environment variable.
  !   2. The directory named in the TEMP environment variable.
  !   3. The directory named in the TMP environment variable.
  !   4. A platform specific location:
  !     Windows
  !         "C:\TEMP", "C:\TMP", "\TEMP", and "\TMP" are tried in that order.
  !     (classic) Macintosh
  !         The TRASH_FOLDER environment variable is used. This is most likely not correct.
  !     Unix
  !         The directories "/tmp", "/var/tmp", and "/usr/tmp" are tried in that order.
  ! Arguments:
  !   tmpdir   Name of the temporary directory
  !
  subroutine filedir_tempdir ( tmpdir )
    ! TODO : how does the user know about the number of characters in the
    ! temporary directory so that he can define its client variable tmpdir ?
    character(len=*), intent(out)             :: tmpdir
    logical :: fexist
    integer :: platform
    character(len=200)             :: envvar
    logical :: tmpdir_found
    character (len=200) :: message
    tmpdir_found = .false.
    !
    ! 1. Try TMPDIR environment variable
    !
    if (.NOT.tmpdir_found) then
       envvar = "TMPDIR"
       call find_tmpdir_in_environment ( envvar , tmpdir , tmpdir_found )
    endif
    !
    ! 2. Try TEMP environment variable
    !
    if (.NOT.tmpdir_found) then
       envvar = "TEMP"
       call find_tmpdir_in_environment ( envvar , tmpdir , tmpdir_found )
    endif
    !
    ! 3. Try TMP environment variable
    !
    if (.NOT.tmpdir_found) then
       envvar = "TMP"
       call find_tmpdir_in_environment ( envvar , tmpdir , tmpdir_found )
    endif
    !
    ! 4. Try platform-specific temporary directories
    !
    if (.NOT.tmpdir_found) then
       platform = platform_get_platform ()
       select case ( platform )
       case ( PLATFORM_PLATFORM_WINDOWS )
          if (.NOT.tmpdir_found) then
             tmpdir = "C:\TEMP"
             tmpdir_found = filedir_exists ( tmpdir )
          endif
          if (.NOT.tmpdir_found) then
             tmpdir = "C:\TMP"
             tmpdir_found = filedir_exists ( tmpdir )
          endif
          if (.NOT.tmpdir_found) then
             tmpdir = "\TEMP"
             tmpdir_found = filedir_exists ( tmpdir )
          endif
          if (.NOT.tmpdir_found) then
             tmpdir = "\TMP"
             tmpdir_found = filedir_exists ( tmpdir )
          endif
       case ( PLATFORM_PLATFORM_UNIX )
          if (.NOT.tmpdir_found) then
             tmpdir = "/tmp"
             tmpdir_found = filedir_exists ( tmpdir )
          endif
          if (.NOT.tmpdir_found) then
             tmpdir = "/var/tmp"
             tmpdir_found = filedir_exists ( tmpdir )
          endif
          if (.NOT.tmpdir_found) then
             tmpdir = "/usr/tmp"
             tmpdir_found = filedir_exists ( tmpdir )
          endif
       case ( PLATFORM_PLATFORM_MAC )
          if (.NOT.tmpdir_found) then
             envvar = "TRASH_FOLDER"
             call find_tmpdir_in_environment ( envvar , tmpdir , tmpdir_found )
          endif
       case default
          write(message,*) "Unknown temporary directory for platform :", platform
          call filedir_error ( "filedir_tempdir" , message )
       end select
    endif
    if (.NOT.tmpdir_found) then
       write(message,*) "Unable to find a temporary directory for platform :", platform
       call filedir_error ( "filedir_tempdir" , message )
    endif
  contains
    subroutine find_tmpdir_in_environment ( envvar , tmpdir , tmpdir_found )
      character(len=*), intent(in) :: envvar
      character(len=*) , intent(out) :: tmpdir
      logical , intent(out) :: tmpdir_found
      character(len=200) :: envvar_value
      tmpdir = ""
      tmpdir_found = .false.
      call platform_get_environment_variable ( envvar , envvar_value )
      if (len_trim(envvar_value)/=0) then
         fexist = filedir_exists ( envvar_value )
         if ( fexist ) then
            tmpdir_found = .true.
            tmpdir = envvar_value
         endif
      endif
    end subroutine find_tmpdir_in_environment
  end subroutine filedir_tempdir
  !
  ! filedir_split --
  !   Computes an array whose elements are the path components in name.
  ! Arguments:
  !   filename   Name of the file to be used
  !   numberOfComponents : the number of items in the list of components
  !   numberOfChars : the number of characters for each component
  !   splitted   The array of splitted names.
  !
  subroutine filedir_split ( filename , numberOfComponents , numberOfChars , listOfComponents )
    character(len=*), intent(in)             :: filename
    integer , intent ( out ) :: numberOfComponents
    integer, intent(out) :: numberOfChars
    character, dimension (:,:), pointer :: listOfComponents
    logical :: findSeparators
    integer :: start
    integer :: component_length
    character ( len = len(filename) ) :: filename_trimmed
    integer :: filename_trimmed_length
    integer :: kseparator
    character ( len = len(filename) ) :: filename_part
    integer :: iComponent
    character :: current_char
    integer :: icharacter
    filename_trimmed = trim ( filename )
    filename_trimmed_length = len_trim ( filename_trimmed )
    !
    ! 1. Count the number of separators in the filename and
    ! the maximum length of all components
    !
    findSeparators = .true.
    start = 1
    numberOfChars = 0
    numberOfComponents = 0
    do while (findSeparators)
       filename_part (1:) = filename_trimmed (start:filename_trimmed_length)
       kseparator = filedir_first_separator_index ( filename_part )
       if ( kseparator == 0 ) then
          ! There are no separators left in the filename
          ! Compute the length of the last component
          component_length = filename_trimmed_length - start + 1
          findSeparators = .false.
       else
          component_length = kseparator - 1
          start = start + kseparator
       endif
       numberOfComponents = numberOfComponents + 1
       numberOfChars = max ( numberOfChars , component_length )
    end do
    !
    ! 2. Fill the array
    !
    allocate ( listOfComponents ( 1 : numberOfChars , 1 : numberOfComponents ) )
    !
    ! 2.1 Initialize with blanks
    !
    do iComponent = 1 , numberOfComponents
       do icharacter = 1 , numberOfChars
          listOfComponents ( icharacter , iComponent ) = " "
       enddo
    enddo
    !
    ! 2.2 Fill components
    !
    findSeparators = .true.
    start = 1
    iComponent = 0
    do while (findSeparators)
       filename_part (1:) = filename_trimmed (start:filename_trimmed_length)
       kseparator = filedir_first_separator_index ( filename_part )
       if ( kseparator == 0 ) then
          ! There are no separators left in the filename
          ! Compute the length of the last component
          component_length = filename_trimmed_length - start + 1
          findSeparators = .false.
       else
          component_length = kseparator - 1
          start = start + kseparator
       endif
       iComponent = iComponent + 1
       !
       ! 2.1 Copy the current component into the list
       !
       do icharacter = 1 , component_length
          current_char (1:) =  filename_part ( icharacter : icharacter + 1 )
          listOfComponents ( icharacter , iComponent ) = current_char
       enddo
    end do
  end subroutine filedir_split
  !
  ! filedir_first_separator_index --
  !   Returns the index of the last separator in the given filename
  !   or 0 if there is no separator in the given file name.
  ! Arguments:
  !   filename   Name of the file to be examined
  !
  integer function filedir_first_separator_index ( filename )
    character (len=1) :: separator
    character(len=*), intent(in)             :: filename
    logical , parameter :: backward = .false.
    separator = filedir_separator ()
    filedir_first_separator_index = scan( filename, separator , backward )
  end function filedir_first_separator_index
  !
  ! filedir_tempfile --
  !   The command generates a temporary file name suitable for writing to, and the 
  !   associated file. The file name will be unique, and the file will be writable and 
  !   contained in the appropriate system specific temp directory. The name of the file 
  !   will be returned as the result of the command.
  ! Arguments:
  !   tempfile   Name of the temporary file
  !
  subroutine filedir_tempfile ( tempfile )
    character(len=*), intent(out)             :: tempfile
    ! TODO : what if the temp file has less characters than the temp dir ?
    character(len=len(tempfile))             :: tempdir
    ! Number of characters for the random file tail
    integer , parameter ::  nrand_chars = 10
    character(len=nrand_chars)             :: randomFileTail
    ! The characters from which the name of the file is made of
    integer , parameter :: setsize = 36
    character, dimension(1:setsize), parameter :: characterSet = (/"a", "b", "c", "d", "e", "f", "g", "h", "i", &
     "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", &
     "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"/)
    integer :: icharacter
    ! Maximum number of tries
    integer , parameter :: maxtries = 10
    integer :: itry
    integer :: random_integer
    real :: alea
    logical :: fexist
    logical :: tempfile_done
    character (len=200) :: message
    call filedir_tempdir ( tempdir )
    !
    ! 1. Loop over the tries
    !
    tempfile_done = .false.
    call random_seed()
    do itry = 1, maxtries
       !
       ! 1.1 Computes a random file tail
       !
       do icharacter = 1, nrand_chars
          call random_number ( alea )
          random_integer = nint( alea * setsize + 1 - alea )
          randomFileTail(icharacter:icharacter) = characterSet ( random_integer )
       end do
       !
       ! 1.2 Computes a full file
       !
       tempfile = filedir_join ( tempdir , randomFileTail )
       !
       ! 1.3 See if the file allready exists
       !
       fexist = filedir_exists ( tempfile )
       if ( .NOT.fexist ) then
          ! If the file does not exist, we have found our temporary file name
          tempfile_done = .true.
          exit
       endif
    end do
    if (.NOT.tempfile_done) then
       write(message,*) "Unable to create a temporary file in directory :", tempdir
       call filedir_error ( "filedir_tempfile_name" , message )
    else
       call filedir_touch ( tempfile )
    endif
  end subroutine filedir_tempfile
  !
  ! filedir_touch --
  !   Implementation of touch. Alter the atime and mtime of the specified files. 
  ! Arguments:
  !   filename   Name of the file to touch
  !   status, optional : if supplied, it contains 0 on success or nonzero error code
  !     upon return
  !
  subroutine filedir_touch ( filename , status )
    character(len=*), intent(in)             :: filename
    integer, intent(out) , optional :: status
    integer :: local_status
    integer :: platform
    character (len= len(filename) + len(command_touch) + 1) :: command
    character (len=200) :: message
    platform = platform_get_platform ()
    select case ( platform )
    case ( PLATFORM_PLATFORM_WINDOWS )
       call filedir_touch_windows ( filename , local_status )
    case ( PLATFORM_PLATFORM_UNIX )
       write ( command , *) trim(command_touch), " ", trim(filename)
       call platform_system ( command , local_status )
    case default
       write(message,*) "Unknown touch command for platform :", platform
       call filedir_error ( "filedir_touch" , message )
    end select
    if (present ( status )) then
       status = local_status
    elseif ( local_status /=0 ) then
       write(message,*) "Unable to touch file :", trim(filename)
       call filedir_error ( "filedir_touch" , message )
    endif
  contains
    !
    ! A rough hack, based on a copy, to make something available under windows.
    ! TODO : make it modify the modification time.
    !
    subroutine filedir_touch_windows ( filename , local_status )
      character(len=*), intent(in)             :: filename
      integer, intent(out) :: local_status
      ! TODO : this will bug if the path to the temporary directory is more than 200 characters !
      character(len=len(filename))             :: tempfile
      logical :: fexist
      character (len=200) :: message
      integer :: file_unit
      fexist = filedir_exists ( filename )
      local_status = 0
      if ( .NOT. fexist ) then
         ! If the file does not exist, create it as an empty file
         file_unit = filedir_get_unit (  )
         open ( UNIT = file_unit , FILE = filename , STATUS ='UNKNOWN', IOSTAT= local_status )
         if ( local_status == 0 ) then
            close ( UNIT = file_unit , IOSTAT= local_status )
         else
            write(message,*) "Unable to touch file :", filename
            call filedir_error ( "filedir_touch" , message )
         endif
      else
         call filedir_tempfile ( tempfile )
         call filedir_delete ( tempfile )
         ! One cannot use the "light" filedir_rename, because it does not modify atime or mtime
         ! So we have to copy
         call filedir_copy ( filename , tempfile )
         call filedir_delete ( filename )
         call filedir_copy ( tempfile , filename )
         call filedir_delete ( tempfile )
      endif
    end subroutine filedir_touch_windows
  end subroutine filedir_touch
  !
  ! filedir_isdirectory --
  !   Returns .true. if file name is a directory, .false. otherwise.
  ! Arguments:
  !   dirname   Name of the directory to be examined
  !
  logical function filedir_isdirectory ( dirname )
    character(len=*), intent(in) :: dirname
    ! TODO : What if the current working directory is longer that the given directory name ?
    character ( len=len(dirname)) :: cwd
    integer :: status
    call filedir_pwd ( cwd )
    call platform_cd ( dirname , status )
    if ( status == 0 ) then
       filedir_isdirectory = .true.
    else
       filedir_isdirectory = .false.
    endif
    call platform_cd ( cwd )
  end function filedir_isdirectory
  !
  ! filedir_pathtype --
  !   Returns one of FS_PATHTYPE_ABSOLUTE, FS_PATHTYPE_RELATIVE, FS_PATHTYPE_VOLUMERELATIVE. 
  !   If name refers to a specific file on a specific volume, the path 
  !   type will be absolute. If name refers to a file relative to the current 
  !   working directory, then the path type will be relative. If name refers to 
  !   a file relative to the current working directory on a specified volume, or to 
  !   a specific file on the current working volume, then the path type is volumerelative.
  ! Arguments:
  !   filename   Name of the file to be examined
  ! Examples :
  !   "." is relative on all platforms
  !   ".." is relative on all platforms
  !   "/" is absolute on Linux/Unix
  !   "C:/" is absolute on Windows (if the C:/ exists)
  !   "/" is volumerelative on windows and refers to the current volume (for example C:/)
  !   "toto.txt" is relative on all platforms
  !   "./toto.txt" is relative on all platforms
  !
  integer function filedir_pathtype ( filename )
    character(len=*), intent(in) :: filename
    integer :: platform
    integer :: firstsep
    character(len=len(filename)) :: firstcomp
    character(len=len(filename)) :: nativename
    nativename = filedir_nativename ( filename )
    firstsep = filedir_first_separator_index ( nativename )
    if (firstsep==0) then
       ! There is no separator
       filedir_pathtype = FS_PATHTYPE_RELATIVE
    elseif (firstsep==1) then
       ! There is one separator, which is the first character
       platform = platform_get_platform ()
       if (platform==PLATFORM_PLATFORM_WINDOWS) then
          filedir_pathtype = FS_PATHTYPE_VOLUMERELATIVE
       else
          filedir_pathtype = FS_PATHTYPE_ABSOLUTE
       endif
    else
       firstcomp = nativename ( 1 : firstsep-1 )
       if ( trim(firstcomp)=="." .OR. trim(firstcomp)=="..") then
          filedir_pathtype = FS_PATHTYPE_RELATIVE
       else
          filedir_pathtype = FS_PATHTYPE_ABSOLUTE
       endif
    endif
  end function filedir_pathtype
  !
  ! filedir_mkdir --
  !   
  ! Arguments:
  !   dirname   Name of the directory to create
  !   status, optional : if supplied, it contains 0 on success or nonzero error code
  !     upon return
  !
  subroutine filedir_mkdir ( dirname , status )
    character(len=*), intent(in) :: dirname
    integer, intent(out) , optional :: status
    integer :: local_status
    character (len=len(dirname)+len(command_mkdir) + 2) :: command
    character(len=len(dirname)+26) :: message
    logical :: isdir
    isdir = filedir_isdirectory ( dirname )
    if (isdir) then
       local_status = -1
    else
       write ( command , *) trim(command_mkdir) , " ",  trim(dirname)
       call platform_system ( command , local_status )
    endif
    if ( present ( status )) then
       status = local_status
    elseif ( local_status /=0 ) then
       write(message,*) "Unable to make directory :", trim(dirname)
       call filedir_error ( "filedir_mkdir" , message )
    endif
  end subroutine filedir_mkdir
  !
  ! filedir_nativename --
  !   Returns the platform-specific name of the file. 
  !   This is useful if the filename is needed to pass to a platform-specific 
  !   call, such as exec under Windows or AppleScript on the Macintosh.
  ! Arguments:
  !   filename   Name of the file name to make platform-specific
  !
  function filedir_nativename ( filename )
    character(len=*), intent(in) :: filename
    character(len=len(filename)) :: filedir_nativename
    integer :: icharacter
    integer :: filelength
    character :: currentcharacter
    filelength = len(filename)
    do icharacter = 1 , filelength
       currentcharacter = filename ( icharacter : icharacter )
       if (currentcharacter=="/") then
          currentcharacter = filedir_separator ( )
       endif
       filedir_nativename ( icharacter : icharacter ) = currentcharacter
    enddo
  end function filedir_nativename
end module m_filedir


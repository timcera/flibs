! filedir.f90 --
!     Manipulate file and directory names
!
!     The module contains the following functions:
!     filedir_rootname       Return the name without an extension
!     filedir_extension      Return the extension
!     filedir_tail       Return the name without the directory (if present)
!     filedir_dirname        Return the directory name
!     filedir_join         Concatenate a directory name and a file name
!     filedir_add_extension  Add an extension to a file name
!
!     The functions actually perform fairly simple string manipulations.
!     It is just that these manipulations occur frequently.
!
!     $Id$
!
module filedir
  use platform, only : &
       platform_get_platform, &
       platform_system, &
       PLATFORM_PLATFORM_WINDOWS, &
       PLATFORM_PLATFORM_UNIX, &
       PLATFORM_PLATFORM_MAC, &
       PLATFORM_PLATFORM_NB, &
       platform_get_environment_variable
  
  implicit none
  
  private
  
  public :: filedir_add_extension
  public :: filedir_atime
  public :: filedir_tail
  public :: filedir_copy
  public :: filedir_copy_std
  public :: filedir_delete
  public :: filedir_dirname
  public :: filedir_exists
  public :: filedir_extension
  public :: filedir_get_cwd
  public :: filedir_get_unit
  public :: filedir_join
  public :: filedir_rename
  public :: filedir_rootname
  public :: filedir_separator
  public :: filedir_normalize
  public :: filedir_findByPattern
  public :: filedir_tmpdir
  public :: filedir_init
  public :: filedir_split
  public :: filedir_first_separator_index
  public :: filedir_last_separator_index
  
  !
  ! Static attributes
  !
  ! Maximum number of columns in a text file
  integer, parameter, public :: MAX_COLUMNS_TEXT = 1000
  ! Maximum number of units when searching for an unused file unit
  integer, parameter, public :: MAX_UNIT_NUMBER = 1000
  ! Maximum string length for the error messages generated by the file subroutines
  integer, parameter, public :: MAX_COMMAND_LENGTH = 1000
  character (len=1), parameter :: PLATFORM_SEPARATOR_UNKNOWN = "?"
  character (len=1), save :: PLATFORM_SEPARATOR = PLATFORM_SEPARATOR_UNKNOWN
  !
  ! Static, Platform-specific commands
  !
  character(len=20), save :: command_ls
  character(len=20), save :: command_copy
  character(len=20), save :: command_mkdir
  character(len=20), save :: command_redirect
  character(len=20), save :: command_suppress_msg
  ! Set to .true. if the static attributes have allready been initialized
  logical :: filedir_static_initialized = .false.
  
contains
  ! filedir_init --
  !     Initialize module internal state.
  ! Arguments:
  !     no argument
  !
  subroutine filedir_init ( )
    implicit none
    integer :: platform
    character (len=200) :: message
    if (.NOT.filedir_static_initialized) then
       !
       ! 0. Get the current platform
       !
       platform = platform_get_platform ()
       !
       ! 1. Initialize the platform-specific separator
       !
       ! Setup the separator depending on the platform
       select case ( platform )
       case ( PLATFORM_PLATFORM_WINDOWS )
          PLATFORM_SEPARATOR = "\"
       case ( PLATFORM_PLATFORM_UNIX )
          PLATFORM_SEPARATOR = "/"
       case ( PLATFORM_PLATFORM_MAC )
          PLATFORM_SEPARATOR = ":"
       case default
          write(message,*) "Unknown separator for platform :", platform
          call filedir_error ( "filedir_init" , message )
       end select
       !
       ! 2. Initialize the platform-specific commands
       !
       select case ( platform )
       case ( PLATFORM_PLATFORM_WINDOWS )
          command_ls = "dir /b"
          command_copy = "copy"
          command_mkdir = "mkdir"
          command_redirect = ">"
          command_suppress_msg = "2>nul"
       case ( PLATFORM_PLATFORM_UNIX )
          command_ls = "ls"
          command_copy = "cp"
          command_mkdir = "md"
          command_redirect = ">"
          command_suppress_msg = "2>/dev/null"
       case default
          write(message,*) "Unknown commands for platform :", platform
          call filedir_error ( "filedir_init" , message )
       end select
       !
       ! Update the static flag
       !
       filedir_static_initialized = .true.
    endif
  end subroutine filedir_init
  
  ! filedir_rootname --
  !     Return the name without the extension (if any)
  ! Arguments:
  !     filename   Name of the file to be examined
  ! Result:
  !     The part of the name _before_ the last "." or the whole name
  !     if no "." is present
  !
  function filedir_rootname ( filename ) result (rootname)
    implicit none
    character(len=*), intent(in)             :: filename
    
    character(len=len(filename)) :: rootname
    
    integer                      :: kdot
    integer                      :: kseparator
    
    kdot   = scan( filename, '.', .true. )
    kseparator = filedir_last_separator_index ( filename )
    
    rootname = filename
    if ( kdot .ne. 0 .and. kdot .gt. kseparator+1 ) then
       rootname = filename(1:kdot-1)
    endif
  end function filedir_rootname
  
  ! filedir_extension --
  !     Return the extension (if any)
  ! Arguments:
  !     filename   Name of the file to be examined
  ! Result:
  !     The part of the name _after_ and including the last "." or empty if none
  !     present
  ! Example : if filename is "declaration.txt", the file extension is ".txt".
  !
  function filedir_extension ( filename ) result (extension)
    implicit none
    character(len=*), intent(in)             :: filename
    
    character(len=len(filename)) :: extension
    
    integer                      :: kdot
    integer                      :: kseparator
    
    kdot   = scan( filename, '.', .true. )
    kseparator = filedir_last_separator_index ( filename )
    
    extension = ''
    if ( kdot .ne. 0 .and. kdot .gt. kseparator+1 ) then
       extension = filename(kdot:)
    endif
  end function filedir_extension
  
  ! filedir_tail --
  !     Returns all of the characters in name after the last directory separator
  ! Arguments:
  !     filename   Name of the file to be examined
  ! Result:
  !     Returns all of the characters in name after the last directory separator
  !     If name contains no separators then returns name.
  !
  function filedir_tail ( filename ) result (basename)
    implicit none
    character(len=*), intent(in)             :: filename
    
    character(len=len(filename)) :: basename
    integer                      :: kseparator
    
    kseparator = filedir_last_separator_index ( filename )
    
    basename = filename
    if ( kseparator .gt. 1 ) then
       basename = filename(kseparator+1:)
    endif
  end function filedir_tail
  
  ! filedir_dirname --
  !     Return the directory (if any)
  ! Arguments:
  !     filename   Name of the file to be examined
  ! Result:
  !     The part of the name _before_ the last directory separator
  !
  function filedir_dirname( filename ) result (dirname)
    implicit none
    character(len=*), intent(in)             :: filename
    
    character(len=len(filename)) :: dirname
    integer                      :: kseparator
    
    kseparator = filedir_last_separator_index ( filename )
    
    dirname = ''
    if ( kseparator .gt. 1 ) then
       dirname = filename(1:kseparator)
    endif
  end function filedir_dirname
  
  ! filedir_last_separator_index --
  !     Returns the index of the last separator in the given filename
  !     or 0 if there is no separator in the given file name.
  ! Arguments:
  !     filename   Name of the file to be examined
  !
  integer function filedir_last_separator_index ( filename )
    implicit none
    character (len=1) :: separator
    character(len=*), intent(in)             :: filename
    logical , parameter :: backward = .true.
    separator = filedir_separator ()
    filedir_last_separator_index = scan( filename, separator , backward )
  end function filedir_last_separator_index
  
  ! filedir_join --
  !     Return the directory plus the file
  ! Arguments:
  !     directory  Name of the directory to be used
  !     filename   Name of the file to be used
  ! Result:
  !     Concatenated directory and file names
  !
  function filedir_join ( directory, filename ) result (fullname)
    implicit none
    character(len=*),intent(in)             :: directory
    character(len=*),intent(in)             :: filename
    
    character(len=len(directory)+len(filename)+1) :: fullname
    
    fullname = trim(directory) // filedir_separator () // filename
  end function filedir_join
  
  ! filedir_add_extension --
  !     Return a new file name with the given extension concatenated.
  !     If the given file name ends with a dot and the given extension begins
  !     with a dot, only one dot is kept.
  ! Arguments:
  !     filename   Name of the file to be used
  !     extension  Extension to be added (e.g. ".txt")
  ! Result:
  !     The file name with an added extension
  ! Note :
  !     The extension of one file begins with a dot : ".txt" is a file
  !     extension while "txt" is not.
  !
  function filedir_add_extension ( filename , extension ) result (newname)
    implicit none
    character(len=*), intent(in)             :: filename
    character(len=*), intent(in)             :: extension
    ! Caution !
    ! The length of the new file is greater that the length of the original file !
    ! This is why the logic must be kept simple :
    ! if one takes into account that the extension may or may not include
    ! 1 dot, the length of the new file is not predictible, that is
    ! may be len(filename)+len(extension) or len(filename)+len(extension) + 1,
    ! which would lead to memory errors if the file names have just the right size.
    character(len=len(filename)+len(extension)) :: newname
    integer :: kdot
    integer :: length_trimmed
    
    kdot    = index( filename , '.', .true. )
    length_trimmed = len_trim(filename)
    if ( kdot == length_trimmed ) then
       ! The file name ends with a dot, so we do not add one.
       newname = trim(filename(1:kdot-1))//trim(extension)
    else
       newname = trim(filename)//trim(extension)
    endif
    
  end function filedir_add_extension
  
  !
  ! filedir_rename --
  !     Renames the file ofdln to newfn by using the RENAME fortran extension.
  ! Arguments:
  !     oldfn : the old file name
  !     newfn : the new file name
  !     status, optional : if supplied, it contains 0 on success or nonzero error code
  !         upon return
  !
  subroutine filedir_rename (oldfn, newfn, status )
    implicit none
    character(len=*), intent(in) :: oldfn, newfn
    integer, intent(out) , optional :: status
    ! Caution !
    ! The RENAME subroutine is not in the fortran 90 standard,
    ! but it is an extension in the fortran compilers Intel, G95 and
    ! gfortran. It may generate errors at link time for other
    ! compilers.
    ! In Intel Fortran 8.0, the status optional argument does not exist
    ! If added to the line "call RENAME ( oldfn , newfn , local_status ),
    ! it generates an error at execution time.
    call RENAME ( oldfn , newfn )
    if ( present ( status )) then
       status = 0
    endif
  end subroutine filedir_rename
  !
  ! filedir_rename --
  !     Copy the file ofdln to newfn by using the SYSTEM fortran extension.
  ! Arguments:
  !     sourcefn : the source file name
  !     targetfn : the target file name
  !     status, optional : if supplied, it contains 0 on success or nonzero error code
  !        upon return
  ! Note :
  !    This subroutine is system-dependent.
  !
  subroutine filedir_copy (sourcefn, targetfn, status )
    implicit none
    character(len=*), intent(in) :: sourcefn, targetfn
    integer, intent(out) , optional :: status
    integer :: local_status
    character (len=MAX_COMMAND_LENGTH) :: command
    character (len=200) :: message
    
    integer :: platform
    ! Get the current platform
    platform = platform_get_platform ()
    ! Setup the separator depending on the platform
    select case ( platform )
    case ( PLATFORM_PLATFORM_WINDOWS )
       write ( command ,*) "copy ", trim(sourcefn), " ", trim(targetfn)
    case ( PLATFORM_PLATFORM_UNIX )
       write ( command ,*) "cp ", trim(sourcefn), " ", trim(targetfn)
    case default
       write(message,*) "Unknown platform :", platform
       call filedir_error ( "filedir_separator" , message )
    end select
    call platform_system ( command, local_status )
    if ( present ( status )) then
       status = local_status
    endif
  end subroutine filedir_copy
  !
  ! filedir_copy_std --
  !    Copy the ascii file ofdln to targetfn by using standard fortran.
  !    If the source file does not exists, generates an error.
  !    If the target file allready exists and force option is undefined
  !    or defined to false, generates an error.
  ! Arguments:
  !    sourcefn : the source file name
  !    targetfn : the target file name
  !    status, optional : if supplied, it contains 0 on success or nonzero error code
  !        upon return
  !       status = 1 when one was unable to open the source file
  !       status = 2 when one was unable to open the target file
  !       status = 3 when there was a problem while writing the target file
  !    force, optional : if supplied and true, if the target file allready exists, delete it before
  !                   making the copy.
  ! Caution !
  !   1. The maximum number of columns in the source filename is 1000.
  !   2. After execution, the target file is not an exact copy of the source file.
  !      Because of the fortran format used, all the lines of the target file are of length 1000 :
  !      blank spaces are appended at the end of the string.
  !
  !
  subroutine filedir_copy_std ( sourcefn , targetfn , status , force )
    implicit none
    character(len = *), intent(in) :: sourcefn, targetfn
    integer, intent(out) , optional :: status
    logical, intent(in) , optional :: force
    integer :: local_status
    integer :: source_unit, target_unit
    character ( len = MAX_COLUMNS_TEXT ) :: string
    integer :: end_of_file
    logical :: fexist
    !
    ! 1. If the target file exists, delete it if force = .true.
    !
    if (present ( force )) then
       if (force) then
          fexist = filedir_exists ( targetfn )
          if (fexist) then
             call filedir_delete ( targetfn )
          endif
       endif
    endif
    !
    ! 2. Get two free file units
    !
    source_unit = filedir_get_unit (  )
    open ( UNIT = source_unit , FILE= sourcefn , ACTION='READ',STATUS='OLD', IOSTAT= local_status )
    if ( local_status /=0) then
       local_status = 1
    else
       target_unit = filedir_get_unit (  )
       open ( UNIT = target_unit , FILE= targetfn , ACTION='WRITE',STATUS='NEW', IOSTAT= local_status )
       if ( local_status /=0) then
          local_status = 2
       else
          !
          ! 3. Copy the lines one after another.
          !
          do
             read ( source_unit , '(a)', iostat = end_of_file ) string
             if ( end_of_file /= 0 ) then
                ! The last line has been found.
                exit
             end if
             write ( target_unit , '(a)', iostat = local_status ) string
             if ( local_status /= 0 ) then
                ! There was an error while writing
                local_status = 3
                exit
             end if
          enddo
          close ( source_unit )
          close ( target_unit )
       endif
    endif
    if ( present ( status )) then
       status = local_status
    endif
  end subroutine filedir_copy_std
  
  !
  ! filedir_get_unit --
  !    Returns a free fortran unit.
  ! Arguments:
  !    no argument
  ! Note :
  !    A "free" FORTRAN unit number is an integer between 1 and MAX_UNIT_NUMBER which
  !    is not currently associated with an I/O device.  A free FORTRAN unit
  !    number is needed in order to open a file with the OPEN command.
  !
  !    If IUNIT = 0, then no free FORTRAN unit could be found, although
  !    all 99 units were checked (except for units 5, 6 and 9, which
  !    are commonly reserved for console I/O).
  !
  !    Otherwise, IUNIT is an integer between 1 and MAX_UNIT_NUMBER, representing a
  !    free FORTRAN unit.  Note that GET_UNIT assumes that units 5 and 6
  !    are special, and will never return those values.
  !
  !  Original Author : John Burkardt
  !
  integer function filedir_get_unit ( )
    
    implicit none
    integer :: iunit
    integer :: ios
    logical :: lopen
    logical :: unit_found
    iunit = 0
    unit_found = .false.
    filedir_get_unit = 0
    do iunit = 1, MAX_UNIT_NUMBER
       if ( iunit /= 5 .and. iunit /= 6 .and. iunit /= 9 ) then
          inquire ( UNIT = iunit, opened = lopen, iostat = ios )
          if ( ios == 0 ) then
             if ( .not. lopen ) then
                filedir_get_unit = iunit
                unit_found = .true.
                exit
             end if
          end if
       end if
    end do
    if (.NOT.unit_found) then
       call filedir_error ( "filedir_get_unit" , "No unit free." )
    endif
  end function filedir_get_unit
  ! filedir_get_cwd --
  !    Returns the name of the current directory by using the fortran
  !    extension GETCWD
  ! Arguments:
  !    cwd : the current working directory
  !
  subroutine filedir_get_cwd ( cwd )
    implicit none
    character(len=*), intent ( out ) :: cwd
    call GETCWD ( cwd )
  end subroutine filedir_get_cwd
  !
  ! filedir_exists --
  !     Returns .true. if file name exists, .false. otherwise.
  ! Arguments:
  !     filename   Name of the file to be examined
  !
  logical function filedir_exists ( filename )
    implicit none
    character(len=*), intent(in) :: filename
    logical :: fexist
    ! Note :
    ! The other possibility is the ACCESS fortran extension
    ! But the "inquire" intrinsic in fortran standard.
    inquire ( FILE = filename , EXIST = fexist )
    if (fexist) then
       filedir_exists = .true.
    else
       filedir_exists = .false.
    endif
  end function filedir_exists
  !
  ! filedir_delete --
  !     Deletes the given file from the file system.
  ! Arguments:
  !     filename   Name of the file to be examined
  !     status, optional : if supplied, it contains 0 on success or nonzero error code
  !        upon return
  !
  subroutine filedir_delete ( filename , status )
    implicit none
    character(len=*), intent(in) :: filename
    integer, intent (out), optional :: status
    integer :: local_status
    integer :: file_unit
    ! One could use the following fortran extension :
    !    call UNLINK ( filename , local_status )
    ! But the following code uses standard fortran statements and therefore
    ! will be full portable.
    file_unit = filedir_get_unit (  )
    open ( UNIT = file_unit , FILE = filename , STATUS ='OLD', IOSTAT= local_status )
    if ( local_status == 0 ) then
       close ( UNIT = file_unit , STATUS = 'DELETE', IOSTAT= local_status )
    endif
    if (present ( status )) then
       status = local_status
    endif
  end subroutine filedir_delete
  !
  ! filedir_atime --
  !    Returns an integer representing the time at which file name was last accessed.
  ! Arguments:
  !    filename : the file name
  !    status, optional : if supplied, it contains 0 on success or nonzero error code
  !      upon return
  ! NOTE :
  !   The CTIME fortran extension is defined in gfortran, in Intel Fortran,
  !   but not in the g95 compiler. So we used the STAT fortran extension :
  !     INTEGER FUNCTION stat(file, sarray)
  !        CHARACTER(LEN=*), INTENT(IN) :: file
  !        INTEGER, INTENT(OUT) :: sarray(13), status
  !     END FUNCTION stat
  !
  integer function filedir_atime ( filename )
    implicit none
    character(len=*), intent(in) :: filename
    integer, dimension (1:13) :: buff
    call STAT ( filename , buff )
    filedir_atime = buff (9)
  end function filedir_atime
  
  ! filedir_separator --
  !     Return the separator for the current platform
  ! Arguments:
  !     no argument
  ! Result:
  !     PLATFORM_SEPARATOR.
  ! Note:
  !     The separator depends on the platform :
  !     - "/" on Unix, Linux systems,
  !     - "\" on Windows systems,
  !     - ":" on Macintosh.
  !
  function filedir_separator ( )
    implicit none
    character :: filedir_separator
    call filedir_init ( )
    filedir_separator = PLATFORM_SEPARATOR
  end function filedir_separator
  
  ! filedir_normalize --
  !     Returns a unique normalized path representation for the
  !     file-system object (file, directory, link, etc), whose string
  !     value can be used as a unique identifier for it. A normalized path
  !     is an absolute path which has all '../', './' removed. Also it is one which
  !     is in the ``standard'' format for the native platform.
  ! Arguments:
  !     filename   Name of the file to be used
  !     normalized  The normalized file name
  !
  function filedir_normalize ( filename )
    implicit none
    character(len=*), intent(in)             :: filename
    character(len=len(filename))             :: filedir_normalize
    character(len=len(filename)) :: directory
    character(len=len(filename)) :: ftail
    
    ! TODO : remove the .. and . in the path, based on filedir_split
    ! TODO : replace base separator into native separator
    call filedir_get_cwd ( directory )
    ftail = filedir_tail ( filename )
    filedir_normalize = filedir_join ( directory , ftail )
    
  end function filedir_normalize
  !
  ! Manage an error for the filedir module
  !
  subroutine filedir_error ( origin , message)
    implicit none
    character(len=*), intent(in) :: origin
    character(len=*), intent(in) :: message
    
    write(6,*) "Internal error from: ", origin
    write(6,*) "Error: ", trim(adjustl(message))
    stop
    
  end subroutine filedir_error
  
  ! filedir_findByPattern --
  !     Returns a list of files fulfilling a particular pattern
  !
  ! Arguments:
  !     pattern         Pattern for the file names (like: *.f90)
  !     list            Allocated list of file names (returned)
  !
  ! Note:
  !     The list of files is an allocated array, the caller should
  !     deallocate it when done.
  !     The length of the character strings in list must be long
  !     enough for the file names. Use for instance a length of at
  !     least 200 characters
  !     The list can zero names long, it will still be allocated.
  ! TODO : extend that subroutine so that it can do an optionnal recursive search into the subdirectories.
  !
  subroutine filedir_findByPattern ( pattern , filelength , numberOfFiles , listOfFiles )
    implicit none
    character(len=*), intent(in)            :: pattern
    integer, intent(in) :: filelength
    integer, intent(out)                    :: numberOfFiles
    ! listOfFiles ( : , ifile) is the file #ifile
    ! listOfFiles ( ichar , ifile ) is the character #ichar for file #ifile
    character, dimension(:,:), pointer :: listOfFiles ! -> does not work
!!$    !character(len=*), dimension(:), pointer :: listOfFiles ! -> does not work
!!$    ! NOTE :
!!$    ! When I test it against Intel Fortran 8 or gfortran 4.0.2, the
!!$    ! program freezes. I have to change the declaration of the list of files to :
!!$    !character(len=50), dimension(1:50) :: listOfFiles -> works fine.
!!$    !character(len=*), dimension(1:50) :: listOfFiles -> does not work
!!$    
    character(len=200)                      :: tmpfile
    character(len=200)                      :: cmd
    
    character(len=1)                        :: line
    integer                                 :: luntmp
    integer                                 :: i
    integer                                 :: ierr
    character (len=1) :: separator
    character(len=20) :: platform_ls
    character (len=200) :: message
    integer :: platform
    character (len=200) :: tempdir
    character(len=200)             :: prefix
    integer :: ifile
    character (len=filelength) :: current_filename
    character (len=filelength) :: full_filename
    integer :: icharacter
    ! NOTE :
    ! I would like to use this declaration instead, but this does not work ????
    !character(len=len(pattern))             :: prefix

    separator = filedir_separator ()
    
    !
    ! 1. Compute the list of files and redirect it to a temporary file.
    !
    call filedir_tmpdir ( tempdir )
    ! TODO  : create a subroutine which returns the path to a temporary file.
    tmpfile = filedir_join ( tempdir , "__filelist__" )
    
    !
    ! Compute the platform-specific ls command
    !
    ! Only file names!
    ! Get the current platform
    platform = platform_get_platform ()
    cmd = trim(command_ls) // ' ' // trim(pattern) // ' ' // trim(command_redirect) // trim(tmpfile) &
         // ' ' // command_suppress_msg
    ! TODO : understand when the command has to be fixed up with "file_correct_separator"
    !cmd = filedir_normalize ( cmd )
    
    !
    ! Under windows, we only get the file tails.
    ! So we have to normalize these files tails to get the full file names.
    !
    if (platform == PLATFORM_PLATFORM_WINDOWS) then
       prefix = pattern
       prefix = filedir_normalize ( prefix )
       i = filedir_last_separator_index ( prefix )
       prefix(i:) = ' '
    endif
    
    call platform_system ( cmd )
    !
    ! 2. Analyse the content of the temporary file.
    !
    luntmp = filedir_get_unit ( )
    open( luntmp , file = tmpfile )
    !
    ! 2.1 Count the number of files, the maximum length of all files
    !
    numberOfFiles = 0
    do
       read( luntmp, '(a)', iostat = ierr ) line
       
       if ( ierr == 0 ) then
          numberOfFiles = numberOfFiles + 1
       else
          exit
       endif
    enddo
    
    rewind( luntmp )
    !
    ! 2.2 Fill the array
    !
    allocate( listOfFiles(1:filelength , 1:numberOfFiles ) )
    
    do ifile = 1 , numberOfFiles
       !read( luntmp, '(a)' ) listOfFiles(ifile,:)
       read( luntmp, '(a)' ) current_filename
       if (platform == PLATFORM_PLATFORM_WINDOWS) then
          full_filename = filedir_join ( prefix , current_filename )
       else
          full_filename = current_filename
       endif
       do icharacter = 1 , filelength
          listOfFiles ( icharacter , ifile ) = full_filename ( icharacter : icharacter )
       enddo
    enddo
    !
    ! 3. Delete the temporary file
    !
    close( luntmp, status = 'delete' )
    
  end subroutine filedir_findByPattern
  
  ! filedir_tmpdir --
  !     Returns the temporary directory for the current platform.
  !     The command returns the path of a directory where the caller can
  !     place temporary files, such as "/tmp" on Unix systems.
  !     The algorithm we use to find the correct directory is as follows:
  !     1. The directory named in the TMPDIR environment variable.
  !     2. The directory named in the TEMP environment variable.
  !     3. The directory named in the TMP environment variable.
  !     4. A platform specific location:
  !        Windows
  !            "C:\TEMP", "C:\TMP", "\TEMP", and "\TMP" are tried in that order.
  !        (classic) Macintosh
  !            The TRASH_FOLDER environment variable is used. This is most likely not correct.
  !        Unix
  !            The directories "/tmp", "/var/tmp", and "/usr/tmp" are tried in that order.
  ! Arguments:
  !     tmpdir   Name of the temporary directory
  !
  subroutine filedir_tmpdir ( tmpdir )
    implicit none
    character(len=*), intent(out)             :: tmpdir
    logical :: fexist
    integer :: platform
    character(len=200)             :: envvar
    logical :: tmpdir_found
    character (len=200) :: message
    tmpdir_found = .false.
    !
    ! 1. Try TMPDIR environment variable
    !
    if (.NOT.tmpdir_found) then
       envvar = "TMPDIR"
       call find_tmpdir_in_environment ( envvar , tmpdir , tmpdir_found )
    endif
    !
    ! 2. Try TEMP environment variable
    !
    if (.NOT.tmpdir_found) then
       envvar = "TEMP"
       call find_tmpdir_in_environment ( envvar , tmpdir , tmpdir_found )
    endif
    !
    ! 3. Try TMP environment variable
    !
    if (.NOT.tmpdir_found) then
       envvar = "TMP"
       call find_tmpdir_in_environment ( envvar , tmpdir , tmpdir_found )
    endif
    !
    ! 4. Try platform-specific temporary directories
    !
    if (.NOT.tmpdir_found) then
       platform = platform_get_platform ()
       select case ( platform )
       case ( PLATFORM_PLATFORM_WINDOWS )
          if (.NOT.tmpdir_found) then
             tmpdir = "C:\TEMP"
             tmpdir_found = filedir_exists ( tmpdir )
          endif
          if (.NOT.tmpdir_found) then
             tmpdir = "C:\TMP"
             tmpdir_found = filedir_exists ( tmpdir )
          endif
          if (.NOT.tmpdir_found) then
             tmpdir = "\TEMP"
             tmpdir_found = filedir_exists ( tmpdir )
          endif
          if (.NOT.tmpdir_found) then
             tmpdir = "\TMP"
             tmpdir_found = filedir_exists ( tmpdir )
          endif
          
       case ( PLATFORM_PLATFORM_UNIX )
          if (.NOT.tmpdir_found) then
             tmpdir = "/tmp"
             tmpdir_found = filedir_exists ( tmpdir )
          endif
          if (.NOT.tmpdir_found) then
             tmpdir = "/var/tmp"
             tmpdir_found = filedir_exists ( tmpdir )
          endif
          if (.NOT.tmpdir_found) then
             tmpdir = "/usr/tmp"
             tmpdir_found = filedir_exists ( tmpdir )
          endif
          
       case ( PLATFORM_PLATFORM_MAC )
          if (.NOT.tmpdir_found) then
             envvar = "TRASH_FOLDER"
             call find_tmpdir_in_environment ( envvar , tmpdir , tmpdir_found )
          endif
          
       case default
          write(message,*) "Unknown temporary directory for platform :", platform
          call filedir_error ( "filedir_tmpdir" , message )
       end select
    endif
    if (.NOT.tmpdir_found) then
       write(message,*) "Unable to find a temporary directory for platform :", platform
       call filedir_error ( "filedir_tmpdir" , message )
    endif
  contains
    subroutine find_tmpdir_in_environment ( envvar , tmpdir , tmpdir_found )
      implicit none
      character(len=*), intent(in) :: envvar
      character(len=*) , intent(out) :: tmpdir
      logical , intent(out) :: tmpdir_found
      character(len=200) :: envvar_value
      tmpdir = ""
      tmpdir_found = .false.
      call platform_get_environment_variable ( envvar , envvar_value )
      if (len_trim(envvar_value)/=0) then
         fexist = filedir_exists ( envvar_value )
         if ( fexist ) then
            tmpdir_found = .true.
            tmpdir = envvar_value
         endif
      endif
    end subroutine find_tmpdir_in_environment
  end subroutine filedir_tmpdir

  ! filedir_split --
  !     Computes an array whose elements are the path components in name.
  ! Arguments:
  !     filename   Name of the file to be used
  !     numberOfComponents : the number of items in the list of components
  !     numberOfChars : the number of characters for each component
  !     splitted   The array of splitted names.
  !
  subroutine filedir_split ( filename , numberOfComponents , numberOfChars , listOfComponents )
    implicit none
    character(len=*), intent(in)             :: filename
    integer , intent ( out ) :: numberOfComponents
    integer, intent(out) :: numberOfChars
    character, dimension (:,:), pointer :: listOfComponents
    
    logical :: findSeparators
    integer :: start
    integer :: component_length
    character ( len = len(filename) ) :: filename_trimmed
    integer :: filename_trimmed_length
    integer :: kseparator
    character ( len = len(filename) ) :: filename_part
    integer :: iComponent
    character :: current_char
    integer :: icharacter

    filename_trimmed = trim ( filename )
    filename_trimmed_length = len_trim ( filename_trimmed )
    !
    ! 1. Count the number of separators in the filename and
    ! the maximum length of all components
    !
    findSeparators = .true.
    start = 1
    numberOfChars = 0
    numberOfComponents = 0
    do while (findSeparators)
       filename_part (1:) = filename_trimmed (start:filename_trimmed_length)
       kseparator = filedir_first_separator_index ( filename_part )
       if ( kseparator == 0 ) then
          ! There are no separators left in the filename
          ! Compute the length of the last component
          component_length = filename_trimmed_length - start + 1
          findSeparators = .false.
       else
          component_length = kseparator - 1
          start = start + kseparator
       endif
       numberOfComponents = numberOfComponents + 1
       numberOfChars = max ( numberOfChars , component_length )
    end do
    !
    ! 2. Fill the array
    !
    allocate ( listOfComponents ( 1 : numberOfChars , 1 : numberOfComponents ) )
    !
    ! 2.1 Initialize with blanks
    !
    do iComponent = 1 , numberOfComponents
       do icharacter = 1 , numberOfChars
          listOfComponents ( icharacter , iComponent ) = " "
       enddo
    enddo
    !
    ! 2.2 Fill components
    !
    findSeparators = .true.
    start = 1
    iComponent = 0
    do while (findSeparators)
       filename_part (1:) = filename_trimmed (start:filename_trimmed_length)
       kseparator = filedir_first_separator_index ( filename_part )
       if ( kseparator == 0 ) then
          ! There are no separators left in the filename
          ! Compute the length of the last component
          component_length = filename_trimmed_length - start + 1
          findSeparators = .false.
       else
          component_length = kseparator - 1
          start = start + kseparator
       endif
       iComponent = iComponent + 1
       !
       ! 2.1 Copy the current component into the list
       !
       do icharacter = 1 , component_length
          current_char (1:) =  filename_part ( icharacter : icharacter + 1 )
          listOfComponents ( icharacter , iComponent ) = current_char
       enddo
    end do


  end subroutine filedir_split

  ! filedir_first_separator_index --
  !     Returns the index of the last separator in the given filename
  !     or 0 if there is no separator in the given file name.
  ! Arguments:
  !     filename   Name of the file to be examined
  !
  integer function filedir_first_separator_index ( filename )
    implicit none
    character (len=1) :: separator
    character(len=*), intent(in)             :: filename
    logical , parameter :: backward = .false.
    separator = filedir_separator ()
    filedir_first_separator_index = scan( filename, separator , backward )
  end function filedir_first_separator_index
  
end module filedir

